<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MySQL</title>
      <link href="/2022/12/15/MySQL/"/>
      <url>/2022/12/15/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL面试"><a href="#MySQL面试" class="headerlink" title="MySQL面试"></a>MySQL面试</h1><h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><h2 id="1、为什么不推荐使用外码键？"><a href="#1、为什么不推荐使用外码键？" class="headerlink" title="1、为什么不推荐使用外码键？"></a>1、为什么不推荐使用外码键？</h2><ul><li><strong>增加了复杂性：</strong> a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦</li><li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li><li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li></ul><p>外码键的<strong>好处</strong>：</p><ul><li><p>保证了数据库数据的一致性和完整性；</p></li><li><p>级联操作方便，减轻了程序代码量</p></li></ul><h2 id="2、范式"><a href="#2、范式" class="headerlink" title="2、范式"></a>2、范式</h2><h3 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式</p><blockquote><p><strong>如果关系表中的属性不可再细分且属性列不可重复，该关系满足第1范式</strong></p></blockquote><h3 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h3><p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键</p><blockquote><p><strong>第二范式要求关系表中所有数据都要和关系表的主键有完全函数依赖（即属性不能只和主键有部分依赖关系）</strong></p></blockquote><h3 id="3NF-第三范式"><a href="#3NF-第三范式" class="headerlink" title="3NF(第三范式)"></a>3NF(第三范式)</h3><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求</p><blockquote><p><strong>每一个非主属性既不部分依赖于码也不传递依赖于码</strong></p></blockquote><p>总：</p><ul><li>1NF：属性不可再分。</li><li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li></ul><h2 id="3、ACID"><a href="#3、ACID" class="headerlink" title="3、ACID"></a>3、ACID</h2><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</li></ol><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的</strong></p><h2 id="4、并发事务的问题"><a href="#4、并发事务的问题" class="headerlink" title="4、并发事务的问题"></a>4、并发事务的问题</h2><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</li></ul><hr><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h1 id="1、基础架构"><a href="#1、基础架构" class="headerlink" title="1、基础架构"></a>1、基础架构</h1><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png"></p><p>MySQL 主要由下面几部分构成：</p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）</li></ul><blockquote><p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件</p><p><strong>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</strong></p></blockquote><ul><li><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p></li><li><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p></li><li><p><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p></li><li><p><strong>日志模块：</strong>在server层是binlog归档日志模块</p></li><li><p><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎</p></li><li><p><strong>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</strong></p></li><li><p><strong>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</strong></p></li></ul><h2 id="MyISAM与InnoDB"><a href="#MyISAM与InnoDB" class="headerlink" title="MyISAM与InnoDB"></a>MyISAM与InnoDB</h2><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎</p><p>MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复</p><p><strong>MyISAM与InnoDB的对比：</strong></p><p>1.<strong>是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code></p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能</p><p><strong>6.索引实现不一样</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录</p><h1 id="2、MySQL事务"><a href="#2、MySQL事务" class="headerlink" title="2、MySQL事务"></a>2、MySQL事务</h1><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong></p><h2 id="1-ACID"><a href="#1-ACID" class="headerlink" title="1.ACID"></a><strong>1.ACID</strong></h2><ol><li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</li></ol><blockquote><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的</strong></p></blockquote><h2 id="2-并发事务的问题"><a href="#2-并发事务的问题" class="headerlink" title="2.并发事务的问题"></a>2.并发事务的问题</h2><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</li><li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</li></ul><p><strong>不可重复读和幻读有什么区别呢？</strong></p><ul><li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读</p><h2 id="3-SQL事务隔离级别"><a href="#3-SQL事务隔离级别" class="headerlink" title="3.SQL事务隔离级别"></a>3.SQL事务隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</li><li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读</li></ul><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p><p>InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别</p><h3 id="解决幻读的方法"><a href="#解决幻读的方法" class="headerlink" title="解决幻读的方法"></a>解决幻读的方法</h3><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p><ol><li>将事务隔离级别调整为 <code>SERIALIZABLE</code> </li><li>在可重复读的事务级别下，给事务操作的这张表添加表锁</li><li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code></li><li>（在InnoDB中）在可重复读隔离级别下使用MVCC</li></ol><h2 id="4-MySQL-的隔离级别是基于锁实现的吗？"><a href="#4-MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="4.MySQL 的隔离级别是基于锁实现的吗？"></a>4.MySQL 的隔离级别是基于锁实现的吗？</h2><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。</p><p>不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读</p><h1 id="3、MySQL锁"><a href="#3、MySQL锁" class="headerlink" title="3、MySQL锁"></a>3、MySQL锁</h1><p><img src="https://static001.geekbang.org/infoq/b0/b06a9b49cfa61b884ff23185aadce275.webp?x-oss-process=image/resize,p_80/format,png"></p><h2 id="1-表级锁和行级锁"><a href="#1-表级锁和行级锁" class="headerlink" title="1.表级锁和行级锁"></a>1.表级锁和行级锁</h2><p><strong>表级锁和行级锁对比</strong> ：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁</li></ul><h2 id="2-行级锁的使用有什么注意事项？"><a href="#2-行级锁的使用有什么注意事项？" class="headerlink" title="2.行级锁的使用有什么注意事项？"></a>2.行级锁的使用有什么注意事项？</h2><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。<strong>这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</strong></p><h2 id="3-共享锁和排他锁"><a href="#3-共享锁和排他锁" class="headerlink" title="3.共享锁和排他锁"></a>3.共享锁和排他锁</h2><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li><strong>排他锁（X 锁）</strong> ：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><table><thead><tr><th align="left"></th><th align="left">S 锁</th><th align="left">X 锁</th></tr></thead><tbody><tr><td align="left">S 锁</td><td align="left">不冲突</td><td align="left">冲突</td></tr><tr><td align="left">X 锁</td><td align="left">冲突</td><td align="left">冲突</td></tr></tbody></table><p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><h2 id="4-意向锁"><a href="#4-意向锁" class="headerlink" title="4.意向锁"></a>4.意向锁</h2><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢？一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁</p><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行所在数据表的对应意向锁</p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（<strong>这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥</strong>）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><h2 id="5-InnoDB-的行锁"><a href="#5-InnoDB-的行锁" class="headerlink" title="5.InnoDB 的行锁"></a>5.InnoDB 的行锁</h2><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><p><strong>记录锁（Record Lock）</strong></p></li><li><p><strong>间隙锁（Gap Lock）</strong> </p></li><li><p><strong>临键锁（Next-key Lock）</strong></p></li></ul><p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</li><li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读</li></ul><h3 id="5-1、记录锁（Record-Lock）"><a href="#5-1、记录锁（Record-Lock）" class="headerlink" title="5.1、记录锁（Record Lock）"></a>5.1、记录锁（Record Lock）</h3><p>也被称为记录锁，属于单个行记录上的锁</p><h3 id="5-2、间隙锁（Gap-Lock）"><a href="#5-2、间隙锁（Gap-Lock）" class="headerlink" title="5.2、间隙锁（Gap Lock）"></a>5.2、间隙锁（Gap Lock）</h3><p>锁定一个范围，不包括记录本身（<strong>只出现在可重复读的事务隔离级别中</strong>）</p><blockquote><p>间隙锁的<strong>例外</strong>：</p><ol><li>如果索引列是唯一索引，那么只会锁住这条记录(只加行锁)，而不会锁住间隙。</li><li>对于联合索引且是唯一索引，如果 where 条件只包括联合索引的一部分，那么依然会加间隙锁</li></ol></blockquote><h3 id="5-3、临界锁（Next-Key-Lock）"><a href="#5-3、临界锁（Next-Key-Lock）" class="headerlink" title="5.3、临界锁（Next-Key Lock）"></a>5.3、临界锁（Next-Key Lock）</h3><p>Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁</p><blockquote><ol><li><strong>临键锁锁定区间和查询范围后匹配值很重要，如果后匹配值存在，则只锁定查询区间，否则锁定查询区间和后匹配值与它的下一个值的区间</strong></li><li><strong>临界锁是相互兼容的，因此可能造成死锁</strong></li></ol></blockquote><h3 id="5-4、插入意向锁-Insert-Intention-lock"><a href="#5-4、插入意向锁-Insert-Intention-lock" class="headerlink" title="5.4、插入意向锁( Insert Intention lock )"></a>5.4、插入意向锁( Insert Intention lock )</h3><p><strong>插入意向锁</strong>是在插入一条记录行前，由 <strong>INSERT</strong> 操作产生的一种<code>间隙锁</code>。该锁用以表示插入<strong>意向</strong>，当多个事务在<strong>同一区间</strong>（gap）插入<strong>位置不同</strong>的多条数据时，事务之间<strong>不需要互相等待</strong>。假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7）之间的<code>间隙锁</code>，但是因为数据行之间并不冲突，所以两个事务之间并<strong>不会产生冲突</strong>（阻塞等待）</p><p>插入意向锁的特性可分为两部分：</p><ol><li><code>插入意向锁</code>是一种特殊的<code>间隙锁</code> —— <code>间隙锁</code>可以锁定<strong>开区间</strong>内的部分记录。</li><li><code>插入意向锁</code>之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（<code>主键</code>、<code>唯一索引</code>）不冲突，那么事务之间就不会出现<strong>冲突等待</strong></li></ol><blockquote><p>需要强调的是，虽然<code>插入意向锁</code>中含有<code>意向锁</code>三个字，但是它并不属于<code>意向锁</code>而属于<code>间隙锁</code>，因为<code>意向锁</code>是<strong>表锁</strong>而<code>插入意向锁</code>是<strong>行锁</strong></p></blockquote><p><strong>为什么要使用插入意向锁？</strong></p><p>我的理解是直接使用间隙锁的话，对于锁住的区间，不同事务想要插入的位置可能不同，在这种情况下会造成频繁的<strong>阻塞等待</strong>，<strong>插入的并发性</strong>非常差，而加入插入意向锁之后就能解决并发插入的问题</p><p><strong>插入意向锁小结：</strong></p><ol><li><strong>MySql InnoDB</strong> 在 <code>Repeatable-Read</code> 的事务隔离级别下，使用<code>插入意向锁</code>来控制和解决并发插入</li><li><code>插入意向锁</code>是一种特殊的<code>间隙锁</code></li><li><code>插入意向锁</code>在<strong>锁定区间相同</strong>但<strong>记录行本身不冲突</strong>的情况下<strong>互不排斥</strong></li></ol><h2 id="6-当前读和快照读区别"><a href="#6-当前读和快照读区别" class="headerlink" title="6.当前读和快照读区别"></a>6.当前读和快照读区别</h2><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE</span><br></pre></td></tr></table></figure><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p><p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><p>当前读的一些常见 SQL 语句类型如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 对读的记录加一个X锁</span><br><span class="line">SELECT...FOR <span class="keyword">UPDATE</span></span><br><span class="line"># 对读的记录加一个S锁</span><br><span class="line">SELECT...LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"># 对修改的记录加一个X锁</span><br><span class="line">INSERT...</span><br><span class="line">UPDATE...</span><br><span class="line">DELETE...</span><br></pre></td></tr></table></figure><h1 id="4、索引"><a href="#4、索引" class="headerlink" title="4、索引"></a>4、索引</h1><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash</strong></p><h2 id="1、索引的底层数据结构"><a href="#1、索引的底层数据结构" class="headerlink" title="1、索引的底层数据结构"></a>1、索引的底层数据结构</h2><h3 id="1-Hash表"><a href="#1-Hash表" class="headerlink" title="1.Hash表"></a>1.Hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））</p><h3 id="2-为什么不使用Hash表作为索引的数据结构？"><a href="#2-为什么不使用Hash表作为索引的数据结构？" class="headerlink" title="2.为什么不使用Hash表作为索引的数据结构？*"></a>2.为什么不使用Hash表作为索引的数据结构？*</h3><p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p><p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点）：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了</p><h3 id="3-B-树-amp-B-树"><a href="#3-B-树-amp-B-树" class="headerlink" title="3.B 树&amp; B+树"></a>3.B 树&amp; B+树</h3><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</li></ul><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p><h3 id="4-MySQL为什么使用B-树"><a href="#4-MySQL为什么使用B-树" class="headerlink" title="4.MySQL为什么使用B+树"></a>4.MySQL为什么使用B+树</h3><ul><li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，<strong>B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</strong></li><li>B+ 树有<strong>大量的冗余节点</strong>（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在<strong>插入、删除的效率都更高</strong>，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li><li>B+ 树叶子节点之间用链表连接了起来，<strong>有利于范围查询</strong>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树</li></ul><h3 id="5-InnoDB是如何存储数据的"><a href="#5-InnoDB是如何存储数据的" class="headerlink" title="5.InnoDB是如何存储数据的"></a>5.InnoDB是如何存储数据的</h3><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p><p>数据库的 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong></p><p>数据页包括七个部分，结构如下图：</p><img src="https://img-blog.csdnimg.cn/img_convert/243b1466779a9e107ae3ef0155604a17.png" style="zoom:67%;" /><p>作用：</p><img src="https://img-blog.csdnimg.cn/img_convert/fabd6dadd61a0aa342d7107213955a72.png" style="zoom:67%;" /><p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表</p><hr><h4 id="User-Records"><a href="#User-Records" class="headerlink" title="User Records"></a>User Records</h4><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p><p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p><p>那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：</p><img src="https://img-blog.csdnimg.cn/img_convert/261011d237bec993821aa198b97ae8ce.png" style="zoom: 50%;" /><p>页目录创建的过程如下：</p><ol><li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li><li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li><li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong></li></ol><p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表</p><hr><p>看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p><p>这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p><ul><li>第一个分组中的记录只能有 1 条记录；</li><li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li><li>剩下的分组中记录条数范围只能在 4-8 条之间。</li></ul><h3 id="6-B-树如何进行查询"><a href="#6-B-树如何进行查询" class="headerlink" title="6.B+树如何进行查询"></a>6.B+树如何进行查询</h3><p>因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p><p>但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p><p>为了解决这个问题，<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I&#x2F;O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p><p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p><img src="https://img-blog.csdnimg.cn/img_convert/7c635d682bd3cdc421bb9eea33a5a413.png" style="zoom:67%;" /><p>通过上图，我们看出 B+ 树的特点：</p><ul><li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li><li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li><li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li></ul><blockquote><p>在InnoDB中，不管是存储目录的数据页其实还是存储真实数据的数据页是一个概念，<strong>它们拥有完全一致的页结构</strong>，不同之处在于 UserRecord存储的真实内容不同，在User Record中的记录有一个字段专门记录当前记录存储的是页面信息还是真实用户数据</p></blockquote><h2 id="2、索引类型"><a href="#2、索引类型" class="headerlink" title="2、索引类型"></a>2、索引类型</h2><h3 id="1-主键索引-Primary-Key"><a href="#1-主键索引-Primary-Key" class="headerlink" title="1.主键索引(Primary Key)"></a>1.主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键</p><h3 id="2-二级索引-辅助索引"><a href="#2-二级索引-辅助索引" class="headerlink" title="2.二级索引(辅助索引)"></a>2.二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置</strong></p><p>唯一索引，普通索引，前缀索引等索引属于二级索引：</p><ol><li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符</li><li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引</li></ol><h3 id="3-聚集索引"><a href="#3-聚集索引" class="headerlink" title="3.聚集索引"></a>3.聚集索引</h3><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p><p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据</p><ul><li>优点：</li></ul><p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据</p><ul><li>缺点：</li></ul><ol><li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的</li></ol><h3 id="4-非聚集索引"><a href="#4-非聚集索引" class="headerlink" title="4.非聚集索引"></a>4.非聚集索引</h3><p><strong>二级索引属于非聚集索引。</strong></p><p>非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</p><ul><li>优点：</li></ul><p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p><ul><li>缺点：</li></ul><ol><li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li><li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li></ol><p><img src="https://img-blog.csdnimg.cn/20210420165311654.png"></p><h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5.覆盖索引"></a>5.覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><h3 id="6-自适应哈希索引"><a href="#6-自适应哈希索引" class="headerlink" title="6.自适应哈希索引"></a>6.自适应哈希索引</h3><p>InnoDB存储引擎会监控对表上各索引页的查询。<strong>如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引(Adaptive Hash Index, AHI)<strong>。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引<br>AHI有一个要求，</strong>对这个页的连续访问模式必须是一样的</strong>。例如对于(a,b)这样的联合索引页，其访问模式可以是下面情况：</p><ol><li>where a&#x3D;xxx</li><li>where a &#x3D;xxx and b&#x3D;xxx</li></ol><p>访问模式一样是指查询的条件是一样的，若交替进行上述两种查询，那么InnoDB存储引擎不会对该页构造AHI。<br>AHI还有下面几个要求：</p><ol><li>以该模式访问了100次</li><li>页通过该模式访问了N次，其中N&#x3D;页中记录*1&#x2F;16</li></ol><p>InnoDB存储引擎官方文档显示，启用AHI后，读取和写入速度可以提高2倍，辅助索引的连接操作性能可以提高5倍。AHI的设计思想是数据库自优化，不需要DBA对数据库进行手动调整</p><h3 id="7-联合索引"><a href="#7-联合索引" class="headerlink" title="7.联合索引"></a>7.联合索引</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong></p><p><strong>联合索引的最左前缀匹配原则</strong></p><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 <strong><code>&gt;</code><strong>、</strong><code>&lt;</code><strong>、</strong><code>between</code></strong> 和 <strong><code>以%开头的like查询</code></strong> 等条件，才会停止匹配。</p><p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</p><p>在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，<strong>联合索引会失效</strong>，这样就无法利用到索引快速查询的特性了。</p><hr><h4 id="联合索引范围查询"><a href="#联合索引范围查询" class="headerlink" title="联合索引范围查询"></a>联合索引范围查询</h4><p>联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p><p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p><p>总的来说，<strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></p><blockquote><p>建议看一下小林coding讲的，讲的很好：<a href="https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB">https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB</a></p></blockquote><hr><h4 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h4><p>针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">asc</span></span><br></pre></td></tr></table></figure><p>有的同学会认为，单独给 status 建立一个索引就可以了。</p><p><strong>但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</strong></p><p>因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。</p><p>所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率</p><h2 id="3、索引下推"><a href="#3、索引下推" class="headerlink" title="3、索引下推"></a>3、索引下推</h2><p>索引下推是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><p>现在我们知道，对于联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p><ul><li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li><li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li></ul><p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化</p><h2 id="4、索引优化"><a href="#4、索引优化" class="headerlink" title="4、索引优化"></a>4、索引优化</h2><p>这里说一下几种常见优化索引的方法：</p><ul><li>前缀索引优化；</li><li>覆盖索引优化；</li><li>主键索引最好是自增的；</li><li>防止索引失效；</li></ul><h3 id="1-前缀索引优化"><a href="#1-前缀索引优化" class="headerlink" title="1.前缀索引优化"></a>1.前缀索引优化</h3><p>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？</p><p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p><p>不过，前缀索引有一定的局限性，例如：</p><ul><li>order by 就无法使用前缀索引；</li><li>无法把前缀索引用作覆盖索引；</li></ul><h3 id="2-覆盖索引优化"><a href="#2-覆盖索引优化" class="headerlink" title="2.覆盖索引优化"></a>2.覆盖索引优化</h3><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p><p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p><p>我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p><p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作</p><h3 id="3-主键索引最好是自增的"><a href="#3-主键索引最好是自增的" class="headerlink" title="3.主键索引最好是自增的"></a>3.主键索引最好是自增的</h3><p>我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？</p><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p><p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p><p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong></p><h3 id="4-索引最好设置为-NOT-NULL"><a href="#4-索引最好设置为-NOT-NULL" class="headerlink" title="4.索引最好设置为 NOT NULL"></a>4.索引最好设置为 NOT NULL</h3><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p><ul><li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li><li>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式<code>COMPACT</code>，会用 1 字节空间存储 NULL 值列表</li></ul><h3 id="5-防止索引失效"><a href="#5-防止索引失效" class="headerlink" title="5.防止索引失效"></a>5.防止索引失效</h3><p>发生索引失效的情况：</p><ul><li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li><li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li><li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li><li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li></ul><blockquote><p>具体了解：<a href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w</a></p></blockquote><h2 id="5、索引失效"><a href="#5、索引失效" class="headerlink" title="5、索引失效"></a>5、索引失效</h2><p>具体看<a href="https://xiaolincoding.com/mysql/index/index_lose.html%EF%BC%8C%E6%87%92%E5%BE%97%E5%86%99%E4%BA%86%EF%BC%8C%E6%9C%89%E7%A9%BA%E5%86%8D%E6%80%BB%E7%BB%93">https://xiaolincoding.com/mysql/index/index_lose.html，懒得写了，有空再总结</a></p><h3 id="1、对索引使用左或者左右模糊匹配"><a href="#1、对索引使用左或者左右模糊匹配" class="headerlink" title="1、对索引使用左或者左右模糊匹配"></a>1、对索引使用左或者左右模糊匹配</h3><h3 id="2、对索引使用函数"><a href="#2、对索引使用函数" class="headerlink" title="2、对索引使用函数"></a>2、对索引使用函数</h3><h3 id="3、对索引进行表达式计算"><a href="#3、对索引进行表达式计算" class="headerlink" title="3、对索引进行表达式计算"></a>3、对索引进行表达式计算</h3><h3 id="4、对索引隐式类型转换"><a href="#4、对索引隐式类型转换" class="headerlink" title="4、对索引隐式类型转换"></a>4、对索引隐式类型转换</h3><h3 id="5、联合索引非最左匹配"><a href="#5、联合索引非最左匹配" class="headerlink" title="5、联合索引非最左匹配"></a>5、联合索引非最左匹配</h3><h3 id="6、WHERE-子句中的-OR"><a href="#6、WHERE-子句中的-OR" class="headerlink" title="6、WHERE 子句中的 OR"></a>6、WHERE 子句中的 OR</h3><h1 id="5、日志（binlog，redo-log和undo-log）"><a href="#5、日志（binlog，redo-log和undo-log）" class="headerlink" title="5、日志（binlog，redo log和undo log）"></a>5、日志（binlog，redo log和undo log）</h1><p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）</p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01.png" style="zoom:67%;" /><h2 id="1、redo-log（重做日志）"><a href="#1、redo-log（重做日志）" class="headerlink" title="1、redo log（重做日志）"></a>1、redo log（重做日志）</h2><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力</p><p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p><p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p><p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p><p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里</p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03.png" style="zoom:67%;" /><h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p><ul><li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li><li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li><li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li></ul><p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p><p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘</p><p><strong>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘</strong></p><p><strong>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘</strong></p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06.png" style="zoom:67%;" /><ul><li><p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失</p></li><li><p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p><p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</p></li><li><p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p><p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失</p></li></ul><h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p><p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p><p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示</p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/10.png" style="zoom:67%;" /><p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p><ol><li><p><strong>write pos</strong> 是当前记录的位置，一边写一边后移</p></li><li><p><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</p></li></ol><ul><li>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</li></ul><p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p><ul><li><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录</p></li><li><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下</p></li></ul><h3 id="为什么要用redo-log"><a href="#为什么要用redo-log" class="headerlink" title="为什么要用redo log"></a>为什么要用redo log</h3><p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p><p>它们不都是刷盘么？差别在哪里？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = 8bit</span><br><span class="line"><span class="number">1</span> KB = <span class="number">1024</span> Byte</span><br><span class="line"><span class="number">1</span> MB = <span class="number">1024</span> KB</span><br><span class="line"><span class="number">1</span> GB = <span class="number">1024</span> MB</span><br><span class="line"><span class="number">1</span> TB = <span class="number">1024</span> GB</span><br></pre></td></tr></table></figure><p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p><p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p><p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移量、更新值，再加上是顺序写，所以刷盘速度很快。</p><p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强</p><h2 id="2、binlog（归档日志）"><a href="#2、binlog（归档日志）" class="headerlink" title="2、binlog（归档日志）"></a>2、binlog（归档日志）</h2><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p><p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p><p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志</p><p>binlog的作用：<strong>主从同步</strong></p><p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性</p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01-20220305234724956.png" style="zoom:67%;" /><p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写</p><h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p><ul><li><strong>statement</strong></li><li><strong>row</strong></li><li><strong>mixed</strong></li></ul><p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/02-20220305234738688.png"></p><p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p><p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下</p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03-20220305234742460.png" style="zoom:67%;" /><p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p><p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p><p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p><p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p><p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p><p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式</p><h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p><p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></p><p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）</p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234747840.png" style="zoom: 50%;" /><ul><li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li><li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li></ul><p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p><ul><li><p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code></p></li><li><p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失。</p><p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样</p></li><li><p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code></p></li></ul><h2 id="3、两阶段提交"><a href="#3、两阶段提交" class="headerlink" title="3、两阶段提交"></a>3、两阶段提交</h2><p><strong><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</strong></p><p><strong><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性</strong></p><p>虽然它们都属于持久化的保证，但是侧重点不同。</p><p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入（刷盘），所以<code>redo log</code>与<code>binlog</code>的写入时机不一样</p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01-20220305234816065.png" style="zoom:67%;" /><p>如果binlog在写入时出了问题，而redo log无问题，则在MySQL恢复数据时主的值为redo中的操作值，而其他如SQL从的值则会跟随binlog恢复而无改变造成数据不一致的问题</p><p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案</p><p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong></p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234956774.png" style="zoom:67%;" /><p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务</p><p>如果<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06-20220305234907651.png" style="zoom:67%;" /><p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据</p><h2 id="4、undo-log"><a href="#4、undo-log" class="headerlink" title="4、undo log"></a>4、undo log</h2><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p><p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p><p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性</p><h1 id="6、MVCC多版本并发控制"><a href="#6、MVCC多版本并发控制" class="headerlink" title="6、MVCC多版本并发控制"></a>6、MVCC多版本并发控制</h1><h2 id="1、一致性非锁定读"><a href="#1、一致性非锁定读" class="headerlink" title="1、一致性非锁定读"></a>1、一致性非锁定读</h2><p>对于 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html"><strong>一致性非锁定读（Consistent Nonlocking Reads）</strong> </a>的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</p><p>在 <code>InnoDB</code> 存储引擎中，<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">多版本控制 (multi versioning)</a> 就是对非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上锁的释放。相反地，<code>InnoDB</code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)</p><p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读</p><h2 id="2、锁定读"><a href="#2、锁定读" class="headerlink" title="2、锁定读"></a>2、锁定读</h2><p>如果执行的是下列语句，就是 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html">锁定读（Locking Reads）</a></p><ul><li><code>select ... lock in share mode</code></li><li><code>select ... for update</code></li><li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li></ul><p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p><ul><li><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</li><li><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li></ul><p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong></p><h2 id="3、InnoDB对MVCC的实现"><a href="#3、InnoDB对MVCC的实现" class="headerlink" title="3、InnoDB对MVCC的实现"></a>3、InnoDB对MVCC的实现</h2><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p><h3 id="1-隐藏字段"><a href="#1-隐藏字段" class="headerlink" title="1.隐藏字段"></a>1.隐藏字段</h3><p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个<strong>隐藏字段：</strong></p><ul><li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li><li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li><li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li></ul><h3 id="2-ReadView"><a href="#2-ReadView" class="headerlink" title="2.ReadView"></a>2.ReadView</h3><p><a href="https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L298"><code>Read View</code></a> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p><p>主要有以下字段：</p><ul><li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li><li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li><li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li><li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li></ul><p><img src="https://javaguide.cn/assets/trans_visible.048192c5.png"></p><h3 id="3-undo-log"><a href="#3-undo-log" class="headerlink" title="3.undo-log"></a>3.undo-log</h3><p><code>undo log</code> 主要有两个作用：</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li></ul><p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种： <code>insert undo log</code> 和 <code>update undo log</code>：</strong></p><ol><li><strong><code>insert undo log</code></strong> ：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作</li><li><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li></ol><p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 <code>undo log</code> 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录</p><h2 id="4、数据可见性算法"><a href="#4、数据可见性算法" class="headerlink" title="4、数据可见性算法"></a>4、数据可见性算法</h2><p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p><p><img src="https://javaguide.cn/assets/8778836b-34a8-480b-b8c7-654fe207a8c2.3d84010e.png"></p><ol><li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</li><li>如果 DB_TRX_ID &gt;&#x3D; m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</li><li>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</li><li>如果 m_up_limit_id &lt;&#x3D; DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）<ul><li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</li><li>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</li></ul></li><li>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</li></ol><h2 id="5、RC-和-RR-隔离级别下-MVCC-的差异"><a href="#5、RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="5、RC 和 RR 隔离级别下 MVCC 的差异"></a>5、RC 和 RR 隔离级别下 MVCC 的差异</h2><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p><ul><li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li><li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li></ul><h2 id="6、MVCC-解决不可重复读问题"><a href="#6、MVCC-解决不可重复读问题" class="headerlink" title="6、MVCC 解决不可重复读问题"></a>6、MVCC 解决不可重复读问题</h2><p>虽然 RC 和 RR 都通过 <code>MVCC</code> 来读取快照数据，但由于 <strong>生成 Read View 时机不同</strong>，从而在 RR 级别下实现可重复读</p><blockquote><p><strong>在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p><p>具体是为什么呢？我的理解是，因为RC隔离级别下，每次select之前都会设置新的Read View，所以对于同一个事务（也就是id一样）来说，在不同的select语句查询之后所处的位置不同，从而可能导致不可重复读，比如都是id为103的事务，在第一次select之前创建的Read View中可能处于当前出现过的最大id（m_low_limit_id）102和最小id（m_up_limit_id）101之间从而不可见，但第二次select后101提交了从而最小id变为102导致读取的Read View（在undo log中查找）就是101修改的从而产生不可重复读</p><p>也就是说对于一个事务A对一个记录进行访问时，不同时期的另一事务B对此事务A的可见性不相同，第一次查询时事务B是不可见的，但在第一次查询到第二次查询的过程中事务B已提交因而事务B对事务A变为可见（Read View新建），这就导致读取的数据改变从而造成不可重复读</p></blockquote><h2 id="7、MVCC➕Next-key-Lock-防止部分幻读"><a href="#7、MVCC➕Next-key-Lock-防止部分幻读" class="headerlink" title="7、MVCC➕Next-key-Lock 防止部分幻读"></a>7、MVCC➕Next-key-Lock 防止部分幻读</h2><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p><p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p><p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p><p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p><p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p><blockquote><p>注意：MVCC并不能完全防止幻读，具体见：<a href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97">RR级别下的幻读</a></p></blockquote><h1 id="7、MySQL内存"><a href="#7、MySQL内存" class="headerlink" title="7、MySQL内存"></a>7、MySQL内存</h1><h2 id="7-1、MySQL一行记录是怎么存储的？"><a href="#7-1、MySQL一行记录是怎么存储的？" class="headerlink" title="7.1、MySQL一行记录是怎么存储的？"></a>7.1、MySQL一行记录是怎么存储的？</h2><p>MySQL默认使用InnoDB存储引擎，所以主要讲InnoDB存储引擎的存储方式</p><h3 id="1-MySQL数据存放在什么文件中"><a href="#1-MySQL数据存放在什么文件中" class="headerlink" title="1.MySQL数据存放在什么文件中"></a>1.MySQL数据存放在什么文件中</h3><p>我们每创建一个 database（数据库） 都会在 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。</p><p>在数据库文件中共有三个文件，这三个文件分别代表着：</p><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.idb）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .idb 文件</li></ul><p>好了，现在我们知道了一张数据库表的数据是保存在「 表名字.idb 」的文件里的，这个文件也称为独占表空间文件</p><h3 id="2-表空间文件的结构"><a href="#2-表空间文件的结构" class="headerlink" title="2.表空间文件的结构"></a>2.表空间文件的结构</h3><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" style="zoom:67%;" /><h4 id="1、行（row）"><a href="#1、行（row）" class="headerlink" title="1、行（row）"></a>1、行（row）</h4><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><p>后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容</p><h4 id="2、页（page）"><a href="#2、页（page）" class="headerlink" title="2、页（page）"></a>2、页（page）</h4><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p><p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。<strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间</p><p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。<strong>数据表中的行记录是用「数据页」来管理的</strong></p><h4 id="3、区（extent）"><a href="#3、区（extent）" class="headerlink" title="3、区（extent）"></a>3、区（extent）</h4><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。</p><p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p><p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p><p>那具体怎么解决呢？</p><p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p><h4 id="4、段（segment）"><a href="#4、段（segment）" class="headerlink" title="4、段（segment）"></a>4、段（segment）</h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合，之前讲<a href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li></ul><h3 id="3-InnoDB-行格式有哪些？"><a href="#3-InnoDB-行格式有哪些？" class="headerlink" title="3.InnoDB 行格式有哪些？"></a>3.InnoDB 行格式有哪些？</h3><p>行格式（row_format），就是一条记录的存储结构。</p><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p><ul><li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li><li>由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</li><li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式</li></ul><h3 id="4-Compact行格式"><a href="#4-Compact行格式" class="headerlink" title="4.Compact行格式"></a>4.Compact行格式</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" style="zoom:67%;" /><p>可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。</p><h4 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h4><p>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息</p><h5 id="1-变长字段长度列表"><a href="#1-变长字段长度列表" class="headerlink" title="1. 变长字段长度列表"></a>1. 变长字段长度列表</h5><p>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p><p>所以，在存储数据的时候要把这些数据占用的字节数也存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p><p>注意：</p><ul><li>这些变长字段的长度值会按照列的顺序<strong>逆序存放</strong></li><li><strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度</li></ul><hr><blockquote><p><strong>为什么「变长字段长度列表」的信息要按照逆序存放？</strong></p></blockquote><p>这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真是数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p><p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p><p>同样的道理， NULL 值列表的信息也需要逆序存放</p><hr><blockquote><p><strong>每个数据库表的行格式都有「变长字段字节数列表」吗？</strong></p></blockquote><p>其实变长字段字节数列表不是必须的。</p><p><strong>当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</strong>，因为没必要，不如去掉以节省空间。</p><p>所以「变长字段长度列表」只出现在数据表有变长字段的时候</p><h5 id="2-NULL-值列表"><a href="#2-NULL-值列表" class="headerlink" title="2. NULL 值列表"></a>2. NULL 值列表</h5><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中</p><p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p><ul><li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li><li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li></ul><p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code></p><hr><blockquote><p>每个数据库表的行格式都有「NULL 值列表」吗？</p></blockquote><p>NULL 值列表也不是必须的。</p><p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以节省 1 字节的空间（NULL 值列表占用 1 字节空间）</p><h5 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3. 记录头信息"></a>3. 记录头信息</h5><p>记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：</p><ul><li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1</li><li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真是数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li><li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li></ul><h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，这三个字段是用于mvcc的，后面有详细的说明就不在这说了</p><h3 id="5-varchar-n-中-n-最大取值为多少？"><a href="#5-varchar-n-中-n-最大取值为多少？" class="headerlink" title="5.varchar(n) 中 n 最大取值为多少？"></a>5.varchar(n) 中 n 最大取值为多少？</h3><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，那 n 最大能设置多少？</p><p>这个问题要考虑两个因素：</p><ul><li>行格式中「变长字段长度列表」最大能表示多少字节？知道了这个才能知道，一行数据最大能存储多少字节的数据。</li><li>数据库表的字符集，确定了这个，才能知道 1 个字符占用多少字节。</li></ul><p>行格式中「变长字段长度列表」有时候是占用 1 字节，有时候是占用 2 字节：</p><ul><li>如果变成字段允许存储的最大字节数小于等于 255 字节，「变长字段长度列表」就占用 1 个字节；</li><li>如果变成字段允许存储的最大字节数大于 255 字节，「变长字段长度列表」就占用 2 个字节；</li></ul><p>可以看到，<strong>「变长字段长度列表」占用的字节数最大不会不超过 2 字节</strong>，2 个字节的最大值是 65535（十进制），<strong>但一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数，所以最多可以存储 65535- 2 - 1 &#x3D; 65532 字节，如果不能为null则为65535-2 &#x3D; 65533字节</strong></p><blockquote><p>具体探索过程看：<a href="https://xiaolincoding.com/mysql/base/row_format.html#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE">varchar(n) 中 n 最大取值为多少？</a>，讲的很好</p></blockquote><h3 id="6-行溢出后，MySQL-怎么处理"><a href="#6-行溢出后，MySQL-怎么处理" class="headerlink" title="6.行溢出后，MySQL 怎么处理"></a>6.行溢出后，MySQL 怎么处理</h3><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p><p><strong>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中</strong>，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示：</p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA.png" style="zoom:67%;" /><p>上面这个是 Compact 行格式在发生行溢出后的处理。</p><p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。</p><p>这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png"></p><h2 id="7-2、BufferPool"><a href="#7-2、BufferPool" class="headerlink" title="7.2、BufferPool"></a>7.2、BufferPool</h2><p>为了提升性能，MySQL使用了缓存技术，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p><p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，<strong>buffer pool会缓存热的数据页和索引页，减少磁盘读操作</strong>，来提高数据库的读性能</p><p>有了缓冲池后：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘</li></ul><blockquote><p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code></p></blockquote><h3 id="1、Buffer-Pool缓存"><a href="#1、Buffer-Pool缓存" class="headerlink" title="1、Buffer Pool缓存"></a>1、Buffer Pool缓存</h3><p>因为InnoDB以页为磁盘和内存交互的基本单位，因此Buffer Pool也需要按页划分</p><p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中</p><p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png" style="zoom:50%;" /><p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等</p><p>控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：</p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" style="zoom:67%;" /><p>上图中控制块和缓存页之间灰色部分称为碎片空间</p><h3 id="2、Buffer-Pool的管理"><a href="#2、Buffer-Pool的管理" class="headerlink" title="2、Buffer Pool的管理"></a>2、Buffer Pool的管理</h3><h4 id="1-空闲页的管理"><a href="#1-空闲页的管理" class="headerlink" title="1.空闲页的管理"></a>1.空闲页的管理</h4><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。</p><p>为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）</p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/freelist.drawio.png" style="zoom: 50%;" /><p>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</p><p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除</p><h4 id="2-脏页的管理"><a href="#2-脏页的管理" class="headerlink" title="2.脏页的管理"></a>2.脏页的管理</h4><p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p><p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/Flush.drawio.png" style="zoom:50%;" /><h4 id="3-如何提高缓存命中率"><a href="#3-如何提高缓存命中率" class="headerlink" title="3.如何提高缓存命中率"></a>3.如何提高缓存命中率</h4><p>Buffer Pool使用LRU算法来提升缓存命中率</p><p>Buffer Pool 里有三种页和链表来管理数据：</p><ul><li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li><li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li><li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表</li><li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpoll_page.png" style="zoom:50%;" /></li></ul><p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p><ul><li>预读失效；</li><li>Buffer Pool 污染；</li></ul><hr><h5 id="预读失效"><a href="#预读失效" class="headerlink" title="预读失效"></a>预读失效</h5><blockquote><p>什么是预读失效？</p></blockquote><p>先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。</p><p>所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。</p><p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p><p>如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉。</p><p>如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率</p><blockquote><p>如何解决预读失效而导致缓存命中率降低的问题？</p></blockquote><p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong>。</p><p>MySQL 改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。</p><p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分</p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/young%2Bold.png" style="zoom:50%;" /><p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p><p>虽然通过划分 old 区域 和 young 区域避免了预读失效带来的影响，但是还有个问题无法解决，那就是 Buffer Pool 污染的问题</p><hr><h5 id="Buffer-Pool污染"><a href="#Buffer-Pool污染" class="headerlink" title="Buffer Pool污染"></a>Buffer Pool污染</h5><blockquote><p>什么是 Buffer Pool 污染？</p></blockquote><p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p><p>注意， Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也可能会造成 Buffer Pool 污染（缓存失效导致全表扫描，从而将热点页淘汰，像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了）</p><blockquote><p>怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？</p></blockquote><p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong></p><p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p><ul><li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li><li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li></ul><p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p><p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p><p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部，young 区域前面 1&#x2F;4 被访问不会移动到链表头部，只有后面的 3&#x2F;4被访问了才会</p><h4 id="4-脏页何时刷入磁盘"><a href="#4-脏页何时刷入磁盘" class="headerlink" title="4.脏页何时刷入磁盘"></a>4.脏页何时刷入磁盘</h4><p>如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不就丢失数据了吗？</p><p>这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p><p>下面几种情况会触发脏页的刷新：</p><ul><li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li><li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li><li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li><li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li></ul><h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p><p>Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。</p><p>Innodb 通过三种链表来管理缓页：</p><ul><li>Free List （空闲页链表），管理空闲页；</li><li>Flush List （脏页链表），管理脏页；</li><li>LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；</li></ul><p>InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：</p><ul><li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。</li><li>当<strong>「页被访问」且「 old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为1秒）」</strong>时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</li></ul><p><strong>写操作是否有数据不一致性问题？</strong></p><p>有缓存时：</p><ul><li>读取数据，会命中缓冲池的页（已经被修改）。</li><li>缓冲池LRU数据淘汰，则会将【脏页】刷回磁盘。</li><li>数据库奔溃，redo log可以恢复数据</li></ul><p>无缓存时：走change buffer</p><ul><li>读取数据，会将Change Buffer中的数据合并到Buffer Pool中。</li><li>如果没有读取，Change也会被被定期刷盘到写缓冲系统表空间。</li><li>数据库奔溃，redo log可以恢复数据</li></ul><h2 id="7-3、Change-Buffer"><a href="#7-3、Change-Buffer" class="headerlink" title="7.3、Change Buffer"></a>7.3、Change Buffer</h2><blockquote><p>缓冲池技术主要对读操作进行了优化，在缓存存在时写操作也很高效，但缓存未命中时，<strong>至少产生一次磁盘IO</strong>，对于写多读少的业务场景可能会消耗大量资源，为了对写操作进行改进，InnoDB实现了写缓冲来提升数据库写性能</p></blockquote><p>写缓冲在MySQL5.5之前，叫插入缓冲(insert buffer)，只针对insert做了优化；现在对delete和update也有效，叫做写缓冲(change buffer)</p><p>它是一种应用在<strong>非唯一普通索引页</strong>(non-unique secondary index page)不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更(buffer changes)，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中的技术。写缓冲的目的是降低写操作的磁盘IO，提升数据库性能</p><blockquote><p><strong>为什么写缓冲优化，仅适用于非唯一普通索引页？</strong></p></blockquote><p>如果索引设置了唯一(unique)属性，在进行修改操作时，InnoDB必须进行唯一性检查。也就是说，索引页即使不在缓冲池，磁盘上的页读取无法避免(否则怎么校验是否唯一？)，此时就应该直接把相应的页放入缓冲池再进行修改，而不应该再整写缓冲这个幺蛾子</p><blockquote><p><strong>哪些场景会触发刷写缓冲中的数据呢？</strong></p></blockquote><ol><li>数据页被访问</li><li>有一个后台线程，会认为数据库空闲时；</li><li>数据库缓冲池不够用时；</li><li>数据库正常关闭时；</li><li>redo log写满时；</li></ol><hr><p>Change Buffer被包含在了Buffer Pool中的，change buffer用的是buffer pool里的内存，由于Buffer Pool的内存大小是有限制的，所以change buffer大小也是有限制的，可通过参数innodb_change_buffer_max_size设置</p><img src="https://img-blog.csdnimg.cn/img_convert/8990f1a8e6fcedcca0b30c231d7a9e98.png" style="zoom:67%;" /><h1 id="8、面经补充"><a href="#8、面经补充" class="headerlink" title="8、面经补充"></a>8、面经补充</h1><h2 id="1、分析一个update语句什么情况下会变得很慢"><a href="#1、分析一个update语句什么情况下会变得很慢" class="headerlink" title="1、分析一个update语句什么情况下会变得很慢"></a>1、分析一个update语句什么情况下会变得很慢</h2><blockquote><p>参考答案，不一定全对</p><ul><li>主键问题导致<strong>分页合并页</strong></li><li>update加载的段太大</li><li><strong>changbuffer</strong>中没有语句命中的行</li><li>有事务先对要更改的数据加锁导致阻塞</li><li>索引失效导致顺序查找</li></ul></blockquote><p>确实是不知道什么是分页合并页以及changebuffer，看面经真是越看越不会。。。 </p><h3 id="1、分页合并页"><a href="#1、分页合并页" class="headerlink" title="1、分页合并页"></a>1、分页合并页</h3><p>InooDB的文件格式，ibd利用主键索引到具体数据，数据都在叶节点上，frm就是一些数据库的元信息了。</p><p>重点看看ibd文件，这个文件由多个段组成，<strong>每个段和一个索引相关</strong>。</p><p>文件的结构是不会随着数据行的删除而变化的，但段则会跟着构成它的更小一级单位——区的变化而变化。页则是区的下一级构成单位，默认体积为16KB。</p><p>每个页（逻辑上讲即叶子节点）是包含了2-N行数据，根据主键排列。</p><p>每个页（逻辑上讲即<a href="https://so.csdn.net/so/search?q=%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020">叶子节点</a>）是包含了2-N行数据，<strong>根据主键排列</strong>。</p><p>InnoDB不是按行的来操作的，它可操作的最小粒度是页，页加载进内存后才会通过扫描页来获取行&#x2F;记录</p><blockquote><p><strong>要注意的是在合并和分裂的过程中会加锁</strong></p></blockquote><h4 id="1-页合并"><a href="#1-页合并" class="headerlink" title="1.页合并"></a>1.页合并</h4><p>当你删了一行记录时，实际上记录<strong>并没有被物理删除</strong>，记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p><p>当页中删除的记录达到<code>MERGE_THRESHOLD</code>（默认页体积的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p><p><strong>页合并发生在删除或更新操作中</strong>，关联到当前页的相邻页。如果页合并成功，在<code>INFOMATION_SCHEMA.INNODB_METRICS</code>中的<code>index_page_merge_successful</code>将会增加</p><h4 id="2-页分裂"><a href="#2-页分裂" class="headerlink" title="2.页分裂"></a>2.页分裂</h4><p>如果一个数据应该被插入第10页，但是10页满了，11页也满了，那怎么办？</p><p>直接把第10页分裂成两个，页分裂会发生在插入或更新，并且造成页的错位（dislocation，落入不同的区）</p><p>InnoDB用<code>INFORMATION_SCHEMA.INNODB_METRICS</code>表来跟踪页的分裂数。可以查看其中的<code>index_page_splits</code>和<code>index_page_reorg_attempts/successful</code>统计。</p><p>一旦创建分裂的页，唯一将原先顺序恢复的办法就是新分裂出来的页因为低于合并阈值（merge threshold）被删掉。这时候InnoDB用页合并将数据合并回来。</p><p>另一种方式就是用<code>OPTIMIZE</code>重新整理表。这可能是个很重量级和耗时的过程，但可能是唯一将大量分布在不同区的页理顺的方法</p><h1 id="附录补充"><a href="#附录补充" class="headerlink" title="附录补充"></a>附录补充</h1><h2 id="1、意向锁"><a href="#1、意向锁" class="headerlink" title="1、意向锁"></a>1、意向锁</h2><p><a href="https://juejin.cn/post/6844903666332368909">为什么要用意向锁</a></p><h2 id="2、不可重复读与幻读的区别"><a href="#2、不可重复读与幻读的区别" class="headerlink" title="2、不可重复读与幻读的区别"></a>2、不可重复读与幻读的区别</h2><p><a href="https://www.zhihu.com/question/392569386">不可重复读与幻读的区别</a></p><h2 id="3、行锁与表锁"><a href="#3、行锁与表锁" class="headerlink" title="3、行锁与表锁"></a>3、行锁与表锁</h2><p><a href="https://zhuanlan.zhihu.com/p/52678870">行锁与表锁</a></p><h2 id="4、时间类数据存储"><a href="#4、时间类数据存储" class="headerlink" title="4、时间类数据存储"></a>4、时间类数据存储</h2><p><a href="https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html#%E4%B8%8D%E8%A6%81%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8%E6%97%A5%E6%9C%9F">Datatime和Timestamp</a></p><p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E6%80%BB%E7%BB%93-%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.jpg"></p><h2 id="5、MySQL中的隐式转换造成的索引失效"><a href="#5、MySQL中的隐式转换造成的索引失效" class="headerlink" title="5、MySQL中的隐式转换造成的索引失效"></a>5、MySQL中的隐式转换造成的索引失效</h2><p><a href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html#%E5%89%8D%E8%A8%80">索引失效</a></p><p>MySQL 使用操作符的一些特性：</p><ol><li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li><li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li><li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li><li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果</li></ol><h2 id="6、MySQL死锁"><a href="#6、MySQL死锁" class="headerlink" title="6、MySQL死锁"></a>6、MySQL死锁</h2><p><a href="https://xie.infoq.cn/article/41285fabb8c4ca612d150b415">死锁</a></p><p>感觉讲的一般</p><h2 id="7、自旋锁与互斥锁"><a href="#7、自旋锁与互斥锁" class="headerlink" title="7、自旋锁与互斥锁"></a>7、自旋锁与互斥锁</h2><p><a href="https://www.jianshu.com/p/a7f349ddcf82">自旋锁</a></p><h2 id="8、MySQL优化"><a href="#8、MySQL优化" class="headerlink" title="8、MySQL优化"></a>8、MySQL优化</h2><p><a href="https://blog.csdn.net/weixin_47162914/article/details/123793589">联合索引最左匹配原则优化</a></p><h2 id="9、RR隔离级别下幻读"><a href="#9、RR隔离级别下幻读" class="headerlink" title="9、RR隔离级别下幻读"></a>9、RR隔离级别下幻读</h2><p><a href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97">RR级别下完全解决幻读了吗</a></p><h2 id="10、索引失效"><a href="#10、索引失效" class="headerlink" title="10、索引失效"></a>10、索引失效</h2><p><a href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2022/12/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2022/12/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="第一章、概述"><a href="#第一章、概述" class="headerlink" title="第一章、概述"></a>第一章、概述</h2><ol><li><p>端系统通过<strong>通信链路</strong>和<strong>分组交换机</strong>连接在一起</p></li><li><p><font color ="red">OSI</font></p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-7-model.png" style="zoom: 80%;" /><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/cs-basics/network/osi-model-detail.png" style="zoom:67%;" /></li><li><p><strong>协议的基本要素：语法、语义和同步</strong></p><ol><li>语法：报文格式</li><li>语义：各字段的含义</li><li>同步：报文传输的先后顺序</li></ol></li><li><p>最著名的分组交换机：</p><ul><li>路由器</li><li>链路层交换机</li></ul></li><li><p>端系统通过因特网服务提供商（Internet Server Provider,ISP）接入因特网，较低的ISP通过国家的国际的较高的ISP互联</p></li><li><p>网络边缘：</p><ul><li>通常把与因特网相连的计算机和其他设备称为端系统，因它们位于因特网边缘所以被称为<strong>端系统</strong></li><li>端系统也称为主机（host）</li><li>主机可划分为：<strong>客户（client）和服务器（server）</strong></li><li>接入网：将端系统物理连接到其边缘路由器（edge router）的网络，边缘路由器是端系统到任何其他远程端系统的路径上的第一台路由器</li></ul></li><li><p>网络核心：</p><ul><li><p><font color ="orange"><strong>分组交换:</strong></font></p><ol><li>**存储转发:**在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接受到整个分组</li><li>特点：（1）报文分组，加首部（2）经路由器储存转发（3）在目的地合并</li></ol></li><li><p><font color ="orange"><strong>电路交换：</strong></font></p><ol><li><strong>频分复用（FDM）</strong></li><li><strong>时分复用(TDM)</strong></li><li>特点：建立电路连接、通话、拆除连接</li></ol></li><li><p>排队时延和分组丢失（丢包）</p></li><li><p>ISP互联：</p><p><img src="https://img-blog.csdnimg.cn/20190816150131417.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3NDI0MjAz,size_16,color_FFFFFF,t_70"></p></li></ul></li><li><p>时延，丢包和吞吐量</p><ul><li>**节点处理时延 $d_{proc}$**（P25）</li><li><strong>排队时延 $d_{queue}$</strong></li><li><strong>传输时延 $d_{trans}$</strong></li><li><strong>传播时延 $d_{prop}$</strong></li><li>传输时延是由路由器推出分组所需要的时间，与<strong>路由器距离无关</strong>；传播时延是一比特从一台路由器传播到另一台路由器所需要的时间，与<strong>分组长度或链路传输速率无关</strong></li><li>总时延：$d_{nodal}&#x3D;d_{proc}+d_{queue}+d_{trans}+d_{prop}$</li></ul></li><li><p>瞬时吞吐量是在任何时间主机接收到文件的速率</p></li><li><p>协议分层：各层的所有协议被称为协议栈</p><ul><li><p><strong>应用层</strong>：是网络应用程序及它们的应用层协议存留的地方。包含HTTP,SMTP,FTP,DNS</p></li><li><p><strong>运输层</strong>：因特网的运输层在应用程序断电之间传送应用层报文，运输层的分组称为<strong>报文段</strong>（segment）</p></li><li><p><strong>网络层</strong>：负责将称为<strong>数据报</strong>（datagram）的网络层分组从一台主机移动到另一台主机。包含TCP,UDP，IP</p></li><li><p><strong>链路层</strong>：网络层将数据报下传给链路层，链路层沿着路径将数据报出传递给下一个节点。链路层分组称为<strong>帧</strong>（frame）</p></li><li><p><strong>物理层</strong>：物理层的任务是将该帧中的<strong>一个个比特</strong>从一个节点移动到下一个节点。该层中的协议是链路相关的并且进一步与该链路的实际传输媒体相关</p></li></ul></li><li><p>增加控制信息:构造协议数据单元 (PDU)</p></li><li><p>控制信息主要包括: </p></li><li><p>地址（Address）: 标识发送端&#x2F;接收端 </p></li><li><p>差错检测编码（Error-detecting code）: 用于差错检测或纠正 </p></li><li><p>协议控制（Protocol control）: 实现协议功能的附加信息，如: 优先级（priority）、服务质量（QoS） 和安全控制等 </p></li><li><p><strong>OSI模型（7层）:应用层、表示层、会话层、传输层、网络层、数据链路层、物理层</strong></p></li></ol><h2 id="第二章、应用层"><a href="#第二章、应用层" class="headerlink" title="第二章、应用层"></a>第二章、应用层</h2><h3 id="2-1、应用层协议原理"><a href="#2-1、应用层协议原理" class="headerlink" title="2.1、应用层协议原理"></a>2.1、应用层协议原理</h3><ol><li>应用程序体系结构：<ol><li>客户-服务器体系结构（client-server architecture）<ul><li>有一个总是打开的主机称为<strong>服务器</strong>，它服务于来自其他称为<strong>客户</strong>的主机的请求</li><li>客户之间不直接通信</li></ul></li><li>P2P体系结构<ul><li>应用程序在间断连接的主机之间使用直接通信，这些主机被称为<strong>对等方</strong></li><li>自扩展性（书P57）</li></ul></li></ol></li><li>进程通信：<ol><li>发起通信的进程标识为<strong>客户</strong>，会话开始时等待联系的进程是<strong>服务器</strong></li><li>进程寻址：通过IP（<strong>32比特</strong>），目的地端口号实现</li></ol></li><li>TCP：<ol><li>面向连接的服务<ul><li>连接是全双工的，即连接双方的进程可以在此连接上同时进行报文收发</li></ul></li><li>可靠的数据传输服务</li><li><strong>面向连接、可靠数据传输、流量控制、拥塞控制；无时延和带宽保证</strong></li></ol></li><li>UDP：<ol><li>UDP是一种不提供不必要服务的轻量级运输协议，它仅提供最小服务</li><li>UDP无连接</li><li>提供不可靠数据传送服务</li><li><strong>不提供建立连接，可靠性，流量控制，拥塞控制；时延和带宽保证</strong></li></ol></li><li>应用层协议定义了运行在不同端系统上的应用程序进程如何相互传递报文</li></ol><h3 id="2-2、Web和HTTP"><a href="#2-2、Web和HTTP" class="headerlink" title="2.2、Web和HTTP"></a>2.2、Web和HTTP</h3><ol><li><p>HTTP概况</p><ol><li><p>Web的应用层协议是超文本传输协议HTTP</p></li><li><p>Web页面（Web page）（也叫文档）是由<strong>对象</strong>组成的。一个对象只是一个文件</p></li><li><p>多数Web页面含有一个HTML基本文件以及几个引用对象</p></li><li><p>HTTP使用TCP</p></li><li><p>HTTP服务器不保存关于客户的任何信息，是一个无状态协议（stateless protocol）</p></li></ol></li><li><p>持续连接：每个请求&#x2F;响应经一个单独的TCP连接发送</p></li><li><p>非持续连接：所有请求&#x2F;响应经相同的TCP连接发送</p></li><li><p><strong>往返时间（Round-Tip Time，RTT）</strong>指一个短分组从客户到服务器然后再返回客户所花费的时间</p></li><li><p>HTTP报文格式：</p><ol><li><p>HTTP请求报文request：</p><ul><li>第一行为请求行，后继的行叫做首部行</li></ul></li></ol><ul><li><p>请求行：</p><ol><li>有三个字段：方法字段，URL字段，HTTP版本字段</li><li>方法字段：GET,POST,HEAD,PUT,DELETE</li></ol><ul><li><p>首部行：</p><ol><li><p>Host指明了对象所在的主机</p></li><li><p>Connection：close 浏览器告诉服务器在发送完请求对象后关闭连接（close为非持续连接）</p></li><li><p>User-agent 指明用户代理，即向服务器发送请求的浏览器类型</p></li><li><p>Accept 表示用户想得到该对象的语法版本</p></li></ol></li></ul><ol start="5"><li>请求报文通用格式：</li></ol><p> 使用GET方法实体体为空，POST方法才使用实体体，其中包含用户在表单字段中的输入值</p><p> 使用GET方法，表单(各字段)输入值被上载,以URL请求行的字段: <a href="http://www.somesite.com/animalsearch?monkeys&banana">www.somesite.com/animalsearch?monkeys&amp;banana</a></p><ul><li>当服务器收到一个HEAD方法方法的请求时，将会用一个HTTP报文响应但不返回请求对象</li></ul></li><li><p>PUT方法允许用户上传对象到指定的Web服务器上的指定路径</p><ul><li>DELETE方法允许用户删除Web服务器上的对象</li></ul></li></ul><ol start="2"><li><p>HTTP响应报文response：</p><ul><li><p>分为1个初始状态行，6个首部行然后是实体体（entity body）</p></li><li><p>实体体部分是报文的主要部分，它包含了所请求对象本身</p></li><li><p>状态行有3个字段：协议版本字段、状态码和相应状态信息</p></li><li><p>首部行：</p><ol><li>Connection：close代表发送完报文后关闭该TCP连接</li></ol></li></ul></li><li><p>Date指示服务器产生并发送该相应报文的日期和时间</p><ol start="3"><li>Server指示该报文是由什么服务器产生的</li><li>Last 指示对象创建或最后修改的日期和时间</li><li>Content-Length指示了被发送对象中的字节数</li><li>Content-Type指示实体体汇总的对象是HTML文本</li></ol></li></ol><ul><li><p>响应报文通用格式：</p></li><li><p>常用状态码及相关短语：</p></li></ul></li><li><p>cookie:</p><ol><li>允许站点对用户进行跟踪</li></ol></li><li><p>Web缓存：</p><ol><li>也叫代理服务器</li><li>目标:在不访问服务器的前提下满足客户端的HTTP请求</li><li>缓存既充当客户端，也充当服务器</li><li>一般由ISP(Internet服务提供商)架设</li><li>为什么需要Web缓存器?<ul><li>减少对客户机请求的响应时间</li><li>减少内部网络与接入链路上的通信量</li><li>能从整体上大大降低因特网上的Web流量</li></ul></li></ol></li><li><p>条件GET方法：</p><ol><li>目的:证实缓存器中的对象是否为最新</li><li>缓存器：在请求报文中包含对象最后修改时间 If-modified-since: date</li><li>服务器: 如果对象是最新的则响应报文中不包含对象且状态行为 HTTP&#x2F;1.0 304 Not Modified</li></ol></li></ol><h3 id="2-3、电子邮件"><a href="#2-3、电子邮件" class="headerlink" title="2.3、电子邮件"></a>2.3、电子邮件</h3><ol><li><p>三个组成部分：用户代理user agents，邮件服务器mail servers，简单邮件传送协议（SMTP）和邮件接收协议</p></li><li><p>客户使用TCP来可靠传输邮件消息到服务器端口号25</p></li><li><p>SMTP：</p><ol><li>用于从发送方的邮件服务器发送报文到接收方的邮件服务器</li><li>直接传送: 发送服务器到接收服务器</li><li>命令: ASCII文本格式</li><li>应答: 状态码及其短语</li><li>邮件消息(header &amp; body)必须是7-bit ASCII</li><li>SMTP使用持久连接</li><li>SMTP服务器使用CRLF.CRLF 来判断邮件消息的结束</li><li>传输的3个阶段：握手 (问候)，邮件消息的传输，结束</li></ol></li><li><p>SMTP和HTTP对比：</p><ol><li>HTTP：拉协议（用户使用HTTP从该服务器拉取这些信息）,SMTP：推协议（发送邮件服务器把文件推向接收服务器）</li><li>都有ASCII 命令&#x2F;应答交互, 状态码</li><li>HTTP: 每个对象封装在它各自的HTTP响应消息中发送</li><li>SMTP: 把所有报文对象放在一个报文中</li></ol></li><li><p>邮件消息的格式：</p><ol><li>每个首部行必须包含一个From首部行和一个To首部行，一个首部也许包含一个Subject首部行及其他可选首部行</li></ol></li><li><p>MIME: Multipurpose Internet mail Extensions多用途因特网邮件扩展, RFC 2045, 2046，增添额外的信头头部声明MIME content-type</p></li><li><p>邮件访问协议：</p><ol><li>因SMTP是推协议，而用户代理从邮件服务器中取得报文是拉动作，所以不能用SMTP</li><li>POP3<ul><li>身份认证 (代理 &lt;–&gt;服务器) 并下载邮件消息</li><li>使用TCP连接</li></ul></li><li>IMAP<ul><li>允许用户像对待本地邮箱那样操纵远程邮箱的邮件</li><li>所有邮件消息保存在一个位置: 服务器</li><li>允许用户利用文件夹组织管理邮件消息</li><li>允许用户代理获取报文某些部分的命令</li></ul></li><li>HTTP：<ul><li>在邮件服务器之间接收和发送邮件仍使用SMTP，但其他两个地方使用HTTP</li></ul></li></ol></li></ol><h3 id="2-4、DNS"><a href="#2-4、DNS" class="headerlink" title="2.4、DNS"></a>2.4、DNS</h3><ol><li><p><strong>功能：</strong></p><ol><li>主机名到IP地址的转换</li><li>主机别名：一个主机可以有一个规范主机名和多个主机别名</li><li>邮件服务器别名</li><li>负载分配：<ul><li>DNS实现冗余服务器：一个IP地址集合可以对应于同一个规范主机名</li></ul></li></ol></li><li><p>DNS协议运行在UDP上，使用53号端口</p></li><li><p>DNS特点分布式数据库：</p><ol><li>一个由分层DNS服务器实现的分布式数据库</li><li>应用层协议：DNS服务器实现域名转换 (域名&#x2F;地址转换)</li></ol></li><li><p>分布式、层次数据库：</p></li><li><p>根DNS服务器，顶级域（Top-Level Domain，TLD）DNS服务器，权威DNS服务器</p></li><li><p>本地DNS服务器：</p><ol><li>严格来说不属于该服务器的层次结构</li><li>每个ISP（如居民区ISP、公司、大学）都有一个本地DNS，也叫默认服务器</li><li>主机发出DNS请求时，该请求被发往本地DNS服务器。起着代理的作用，转发请求到层次结构中</li></ol></li><li><p>DNS查询方法：</p><ol><li>递归查询<ul><li>名字解析的负担交给被查询的名字服务器</li></ul></li><li>迭代查询</li><li>任何DNS查询可以既是递归的也是迭代的</li><li>实践中通常为从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的</li></ol></li><li><p>DNS记录：</p><ol><li><p>DNS: 存储资源记录(RR，Resource Records)的分布式数据库，RR提供了主机名到ip地址的映射</p></li><li><p>资源记录（Resource Records，RR）书P89</p><ul><li>格式: (name, value, type,ttl)</li><li>ttl是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间</li><li>Name和Value的值取决于Type</li><li>Type&#x3D;A（Address），name &#x3D; 主机名，value &#x3D; IP地址（A类型的RR提供了标准主机名到ip地址的映射）</li><li>Type&#x3D;NS（ name server ），name &#x3D; 域名（如foo.com）， value &#x3D; 该域权威名字服务器的主机名（这个RR用于沿着查询链来路由DNS查询）</li><li>Type&#x3D;CNAME（canonical），name &#x3D; 主机别名 （如 <a href="http://www.ibm.com的真名为servereast.backup2.ibm.com)/">www.ibm.com的真名为servereast.backup2.ibm.com）</a> ，value &#x3D; 真实的规范主机名</li><li>Type&#x3D;MX（mail exchange），name &#x3D;邮件服务器的主机别名，value &#x3D;邮件服务器的真实规范主机名</li></ul></li><li><p>如果一台DNS服务器是用于某特定主机名的权威DNS服务器，那么该DNS服务器会有一条包含用于该主机名的类型A记录（即使该DNS服务器不是其权威DNS服务器，它也可能在缓存中包含有一条类型A记录)</p></li><li><p>如果服务器不是用于某主机名的权威服务器,那么该服务器将包含一条类型NS记录，该记录对应于包含主机名的域;它还将包括一条类型A记录，该记录提供了在NS记录的Value字段中的 DNS服务器的IP地址</p></li></ol></li><li><p>DNS报文：</p><ol><li><p>DNS只有查询和回答报文，且具有相同格式</p></li><li><p>前12字节是首部区域</p><ul><li>标识符: 16位，查询和应答报文使用相同的标识符</li><li>标志:有若干个标志构成，分别标识不同的功能</li><li>问题区域包含正在进行的查询信息，包含名字字段和类型字段</li></ul></li></ol></li><li><p><strong>在DNS数据库中插入记录</strong></p></li><li><p>内容分发网络(Content distribution networks, CDN)：主要是截获和重定向请求</p></li></ol><h2 id="第三章、运输层"><a href="#第三章、运输层" class="headerlink" title="第三章、运输层"></a>第三章、运输层</h2><h3 id="3-1、多路分解与多路复用"><a href="#3-1、多路分解与多路复用" class="headerlink" title="3.1、多路分解与多路复用"></a>3.1、多路分解与多路复用</h3><ol><li><p>在接收主机多路分解:将接收到的数据段传递到正确的套接字</p></li><li><p>在发送主机多路复用:从多个套接字收集数据, 用首部封装数据，然后将报文段传递到网络层</p></li><li><p>网络层:两个主机之间的逻辑通信；</p><p>传输层:两个进程之间的逻辑通信</p></li><li><p>端口号大小为16比特，0-1023范围的端口号称为周知端口号</p></li><li><p>无连接多路分解：</p><ol><li>UDP套接字由二元组标识（目的地IP地址, 目的地端口号）</li><li>具有不同的源IP地址且&#x2F;或源端口号，但具有相同的目的IP地址和目的端口号的IP报文段指向同样的套接字</li></ol></li><li><p><strong>面向连接的多路分解</strong>：</p><ol><li>TCP 套接字由4部分指定: （源IP地址，源端口号，目的IP地址，目的端口号）</li></ol></li></ol><h3 id="3-2、UDP"><a href="#3-2、UDP" class="headerlink" title="3.2、UDP"></a>3.2、UDP</h3><ol><li><p>“尽力而为”服务，UDP段可能：</p><p>• 丢包</p><p>• 对应用程序交付失序</p></li><li><p>为何要有 UDP协议? </p><p>• 无连接创建(它将增加时延) </p><p>• 简单：在发送方、接收方无连接状态</p><p>• 段首部小，UDP首部只有8字节，TCP有20字节</p><p>• 无拥塞控制: UDP能够尽可能快地传输</p></li><li><p>应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文</p></li><li><p>UDP首部格式：</p><ul><li>首部字段有 8 个字节，由 4 个字段组成，每个字段都是两个字节</li></ul></li><li><p>经UDP的可靠传输 : 在应用层增加可靠性</p><p>• 应用程序特定的差错恢复</p></li><li><p><strong>UDP校验和</strong></p><p>加法有溢出则进行回卷</p><p>在计算检验和时，临时把“伪首部”和 UDP 用户数据报连接在一起</p></li></ol><h3 id="3-3、可靠数据传输协议"><a href="#3-3、可靠数据传输协议" class="headerlink" title="3.3、可靠数据传输协议"></a>3.3、可靠数据传输协议</h3><ol><li><p>rdt1.0</p></li><li><p>rdt2.0</p><ul><li>停等协议：发送方发送一个报文，然后等待接受方的响应，在等待时不能从上层获得更多的数据</li></ul></li><li><p>rdt2.1</p><ul><li><p>处理冗余: </p><p>• 发送方对每个分组增加<em>序列号</em></p><p>• 如果ACK&#x2F;NAK受损，发送方重传当前的分组</p><p>• 接收方丢弃(不再向上交付)冗余分组</p></li></ul></li><li><p>rdt2.2：一个不要NAK的协议</p><ul><li><p>同 rdt2.1一样的功能, 只用 ACKs </p></li><li><p>代替NAK,接收方对最后正确接收的分组发送ACK</p><p>•  接收方必须明确包含被确认的报文的序号</p></li><li><p>发送方收到重复 ACK 将导致和 NAK一样的处理: 重发当前报文</p></li></ul></li><li><p>rdt3.0：具有出错和丢失的信道</p><ul><li><p>发送方等待ACK一段“合理的”时间</p><p>• 如在这段时间没有收到ACK则重传</p><p>• 如果分组(或ACK)只是延迟(没有丢失)： </p><p>​     重传将是冗余的，但序号的使用已经处理了该情况；</p><p>​     接收方必须定义被确认的分组序号</p><p>• 需要倒计时定时器</p></li></ul></li><li><p>流水线可靠数据传输协议：</p><ul><li><p>流水线: 发送方允许发送多个 “在路上的”, 还没有确认的报文</p><p>• 序号数目的范围必须增加</p><p>• 在发送方&#x2F;接收方必须有缓冲区</p></li></ul></li><li><p>解决流水线的差错恢复的两种基本方法：回退N步（Go-Back-N,GBN）和选择重传（Selective Repeat,SR）</p></li><li><p><strong>回退N步：</strong></p><ol><li><p>又称为滑动窗口协议</p></li><li><p>发送方：</p><ul><li><p>ACK(n): 确认所有的（包括序号n）的分组 - “累计ACK”（可能收到重复的ack）</p></li><li><p>对每个传输中的分组的用同一个计时器</p><p>对第一个发送未被确认的报文定时</p></li><li><p>timeout(n):若超时，重传窗口中的分组n及所有更高序号的分组</p></li></ul></li><li><p>接收方：</p><ul><li><p>对失序的分组: </p><p>• 丢弃 (不缓存) -&gt; 没有接收缓冲区! </p><p>• 重新确认具有按序的分组</p></li><li><p>只有ACK: 对接收的分组总是发送具有最高按序序号的ACK</p></li></ul></li></ol></li><li><p><strong>选择重传：</strong></p><ol><li>接收方分别确认已经收到的分组，必要时，缓冲报文, 最后按序提交给上层</li><li>发送者只重发没有收到确认的分组对每个没有确认的报文发送者都要启动一个定时器(每个未被确认的报文都有一个定时器) </li><li>窗口长度必须小于或等于序号空间大小的一半</li></ol></li></ol><h3 id="3-4、TCP"><a href="#3-4、TCP" class="headerlink" title="3.4、TCP"></a>3.4、TCP</h3><ol><li><p>概述：</p><ol><li><p>**点到点: **一个发送方, 一个接收方</p></li><li><p><strong>面向连接:</strong> </p><p>• 在进行数据交换前，初始化发送方与接收方状态，进行握手(交换控制信息)。 </p><p>• 连接状态与端系统有关，不为路由器所知</p></li><li><p><strong>全双工数据:</strong> </p><p>• 同一连接上的双向数据流</p></li><li><p>TCP采用<strong>累计确认</strong></p></li></ol></li><li><p><strong>发送和接收缓冲区</strong></p></li><li><p>MSS: 最大报文段长度，通常根据最初确定的由本地发送主机发送的最大链路层帧（最大传输单元，MTU）长度来设置</p></li><li><p>设置MSS要保证一个TCP报文段加TCP&#x2F;IP首部长度（通常40字节）将适合单个链路层帧</p></li><li><p>MSS指在<strong>报文段里应用层数据的最大长度，而不包括首部的TCP报文段的长度</strong></p></li><li><p>TCP面向流的概念：</p><ol><li>**可靠、有序的字节流:**没有 “报文边界”</li><li><strong>流水线:</strong> TCP拥塞和流量控制设置滑动窗口协议</li><li><strong>流量控制:</strong> 发送方不能淹没接收方</li><li><strong>拥塞控制:</strong> 抑止发送方速率来防止过分占用网络资源</li></ol></li><li><p><strong>TCP报文段结构：</strong></p><ol><li><p>TCP首部一般为<strong>20字节</strong>（选项字段为空）：</p><ol><li><p><strong>源端口和目的端口字段——各占 2 字节</strong></p><ul><li>端口是运输层与应用层的服务接口。运输层的复用和分解功能都要通过端口才能实现</li></ul></li><li><p><strong>序号字段——占 4 字节</strong></p><ul><li><p>TCP 连接中传送的数据流中的<strong>每一个字节都编上一个序号</strong></p></li><li><p>序号字段的值则指的是本报文段所发送的数据的<strong>第一个字节的序号</strong></p></li></ul></li><li><p><strong>确认号字段——占 4 字节</strong></p><ul><li>是期望收到对方的下一个报文段的数据的第一个字节的序号</li></ul></li><li><p>首部长度（即数据偏移）——占 4 比特</p><ul><li><p>指示了以32比特的字为单位的TCP首部长度。也就是说，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远，因TCP首部长度可变</p></li><li><p>“数据偏移”的单位是 32 位字（以 4 字节为计算单位）</p></li></ul></li><li><p>保留字段——占 6 比特</p><ul><li>保留为今后使用，但目前应置为 0</li></ul></li><li><p>标志字段——占6比特</p><ul><li><p>紧急 URG —— 当 URG &#x3D; 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)，紧急数据的最后一个字节由16比特的紧急数据指针字段指出</p></li><li><p>确认 ACK —— 只有当 ACK &#x3D; 1 时确认号字段才有效。当ACK &#x3D; 0 时，确认号无效</p></li><li><p>推送 PSH (PuSH) —— 接收 TCP 收到 PSH &#x3D; 1 的报文段，就尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付</p></li><li><p>复位 RST (ReSeT) —— 当 RST &#x3D; 1 时，表明 TCP 连接中出现严重差错（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立运输连接</p></li><li><p>同步 SYN —— 同步 SYN &#x3D; 1 表示这是一个连接请求或连接接受报文</p></li><li><p>终止 FIN (FINis) —— 用来释放一个连接。FIN &#x3D; 1 表明此报文段的发送端的数据已发送完毕，并要求释放运输连接</p></li></ul></li><li><p>窗口字段 —— 占 2 字节</p><ul><li><p>用来让对方设置发送窗口的依据，单位为字节。</p></li><li><p>用于流量控制，用于指示作为接受方，愿意接受的字节数量</p></li></ul></li><li><p>检验和 —— 占 2 字节</p><ul><li><p>检验和字段检验的范围包括首部和数据这两部分</p></li><li><p>在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部</p></li></ul></li><li><p>紧急指针字段 —— 占 16 位</p><ul><li>指出紧急数据最后一个字节的位置，也就是指出在本报文段中，紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）</li></ul></li><li><p>选项字段——可扩展</p></li><li><p>填充字段 —— 这是为了使整个首部长度是 4 字节的整数倍</p></li></ol></li><li><p><strong>序号:</strong> 报文段中第1个数据字节在字节流中的位置编号</p></li><li><p><strong>确认号:</strong> </p><p>• 期望从对方收到下一个字节的序号</p><p>• 累积确认</p></li><li><p>问：接收方如何处理失序报文段？</p><p>回答：TCP规范没有说明， 由实现者自行选择实现: 抛弃&#x2F;缓存</p></li></ol></li><li><p>TCP往返时延的估计和超时：</p><ol><li><p>估计往返时间：</p><ul><li><p>样本RTT（SampleRTT）: 测量从报文段发送到收到确认的时间</p></li><li><p>TCP维持一个SampleRTT均值（称为EstimatedRTT）</p></li><li><p>一旦获得一新RTT，TCP根据指数加权平均更新EstimatedRTT, $\alpha$ 推荐值为0.125</p><p>$EstimatedRTT &#x3D; (1-\alpha)*EstimatedRTT+\alpha *SampleRTT$</p></li><li><p>DevRTT：RTT的偏差，用于估算SampleRTT一般会偏离EstimatedRTT的程度, $\beta$ 推荐值为0.25</p><p>$DevRTT&#x3D;(1-\beta)*DevRTT+\beta *|SampleRTT-EstimatedRTT|$</p></li></ul></li><li><p>设置超时：</p><ul><li><p>超时间隔应等于EstimtedRTT 加上 “安全余量”</p><p>EstimatedRTT变化大 -&gt; 更大的安全余量</p></li><li><p>超时间隔：$TimeoutInterval &#x3D; EstimatedRTT + 4*DevRTT$</p></li></ul></li><li><p>初始化超时：</p><ul><li><p>初始时TimeoutInterval设置为1秒</p></li><li><p>第一个样本RTT获得后， </p><p>$EstimatedRTT&#x3D;SampleRTT$，</p><p>$DevRTT&#x3D;SampleRTT&#x2F;2$，</p><p>$TimeoutInterval &#x3D;EstimatedRTT + max (G, K*DevRTT) $</p><p>（K&#x3D;4，G是用户设置的时间粒度）</p></li></ul></li></ol></li><li><p>可靠数据传输：</p><ol><li><p>TCP在IP不可靠服务的基础上创建可靠数据传输服务</p><p>• 肯定确认和定时器</p><p>• 序号、重传</p></li><li><p>TCP使用单个重传计时器</p></li><li><p>重传被下列事件触发: </p><p>• 超时事件</p><p>• 重复ACK</p></li><li><p>定时器与最早没有被确认的报文段关联</p></li><li><p><strong>超时间隔加倍</strong>：</p><ul><li>TCP每次重传，都会把下一次的超时间隔设置为先前值的两倍</li><li>但是当<strong>收到上层应用的数据</strong>和<strong>收到ACK</strong>两个事件中的任何一个发生时，定时器的TimeoutInterval值恢复为由近期的EstimatedRTT和DevRTT计算得到</li><li>这种修改，提供了一种形式受限的拥塞控制</li></ul></li><li><p><strong>快速重传</strong></p><ol><li><p>发送方可以在超时之前通过重复的ACK检测丢失报文段</p></li><li><p>如果发送方收到3个对同样报文段的冗余确认，则发送方认为该报文段之后的数据已经丢失。</p><p>• 启动快速重传: 在定时器超时之前重发丢失的报文段</p></li><li><p>冗余ACK：再次确认某个报文段的ACK</p></li></ol></li></ol></li><li><p><strong>流量控制</strong>（书P165）</p><ol><li><p>流量控制：发送方不能发送的太多太快，让接收缓冲区溢出</p></li><li><p>TCP通过让发送方维护一个接收窗口的变量来提供流量控制</p></li><li><p>发送方要限制未确认的数据不超过缓存</p><p>$LastByteSent-LastByteAcked &lt;&#x3D; RcvBuffer$</p></li><li><p>缓冲区的剩余空间也就是接收窗口：$rwnd&#x3D; RcvBuffer-[LastByteRcvd -LastByteRead] $</p></li><li><p>由于该空间是随时间变化的，所以rwnd也是<strong>动态的</strong></p></li><li><p>接收方在报文段接收窗口字段中通告其接收缓冲区的剩余空间</p></li><li><p>当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段（防止主机A被永远阻塞，书上例子很详细）</p></li></ol></li><li><p>TCP连接管理</p><ol><li><p>三次握手：</p><ol><li>步骤 1: 客户机向服务器发送 TCP SYN报文段<ul><li>随机指定初始序号（client_isn）放于TCP报文段首部的序号字段中</li><li>没有数据</li><li>首部SYN比特置1</li></ul></li><li>步骤 2: 服务器收到SYN报文段, 用SYNACK报文段回复<ul><li>服务器为该连接分配缓冲区和变量</li><li>指定服务器初始序号（server_isn）放于TCP报文段首部的序号字段中</li><li>首部SYN比特置1</li><li>首部确认号字段置client_isn+1</li></ul></li><li>步骤3：客户机接收到 SYNACK<ul><li>客户机为该连接分配缓冲区和变量</li><li>用ACK报文段确认回复（该客户通过将值server_isn+1放置到TCP报文段首部的确认字段中完成）</li><li>可能包含数据</li><li>SYN比特置0</li></ul></li></ol></li><li><p>关闭连接：</p><ol><li><p>Step 1: 客户发送 TCP FIN 控制报文段到服务器</p></li><li><p>Step 2: 服务器接收 FIN, 回复 ACK. 半关闭连接, 并发送FIN到客户</p></li><li><p>Step 3: 客户接收 FIN, 回复 ACK. </p><p>进入 “timed wait”状态</p><p>等待结束时释放连接资源</p></li><li><p>Step 4: 服务器接收 ACK. 连接关闭</p></li></ol></li><li><p>TCP状态转化：</p><ol><li><p>客户端</p></li><li><p>服务器端</p></li></ol></li></ol></li><li><p><strong>拥塞控制原理</strong></p><ol><li>拥塞: 从信息角度看: “太多源主机发送太多的数据，速度太快以至于网络来不及处理”</li><li>表现:<ul><li>丢失分组 (路由器的缓冲区溢出)</li><li>长延迟 (在路由器的缓冲区排队)</li></ul></li><li>拥塞网络的代价：<ol><li>当分组的到达速率接近链路容量时，分组经历巨大的排队时延</li><li>发送方必须执行重传以补偿因为缓存溢出而丢弃（丢失）的分组</li><li>发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本</li><li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了</li></ol></li><li>拥塞控制方法：<ol><li>根据网路层是否为运输层拥塞控制提供了<strong>显示帮助</strong>，来区分拥塞控制方法</li><li>端到端拥塞控制<ol><li>网路层没有为运输层提供显示的支持</li><li>从端系统根据观察到的时延和丢失现象推断出拥塞</li><li>TCP采用此方法</li><li>TCP报文段的丢失（超时或3次冗余确认）被认为是网络拥塞的一个迹象</li></ol></li><li>网络辅助的拥塞控制<ol><li>路由器向发送方提供关于网络中拥塞状态的显示反馈信息</li><li>一个bit指示一条链路出现拥塞(SNA,DECnet) </li><li>指示发送方按照一定速率发送（ATM）</li><li>两种形式发送拥塞信息<ul><li>直接反馈信息可以由网络路由器发给发送方。这种方式的通知通常采用了一种阻塞分组 （choke packet)的形式（主要是说:“我拥塞了!”)。</li><li>路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。一旦收到一个标记的分组后，接收方就会向发送方通知该网络拥塞指示。注意到后一种形式的通知至少要经过一个完整的往返时间。</li></ul></li></ol></li></ol></li></ol></li><li><p><strong>TCP拥塞控制</strong></p><ol><li><p>采用端到端控制 (没有网络辅助)</p></li><li><p>发送方通过<strong>cwnd拥塞窗口（congestion window）</strong>限制传输:LastByteSent-LastByteAcked&lt;&#x3D;min{ cwnd，rwnd}</p></li><li><p>拥塞窗口是动态的, 通过调节cwnd的值，发送方因此能调整它向连接发送数据的速率</p></li><li><p>发送方如何感知网络拥塞? </p><p>• 丢失事件 &#x3D; 超时<em>或者</em> 3个重复ACK</p><p>• 发生丢失事件后，TCP发送方降低速率(拥塞窗口) </p><p>• 正常时增加发送速率，自计时</p></li><li><p>TCP发送方怎样确定它应当发送的速率呢?</p><ol><li>一个丢失的报文段意味着拥塞，应当降低TCP发送速率</li><li>当收到未确认报文段的确认到达时，能够增加发送方的速率</li><li>带宽探测</li></ol></li><li><p>TCP拥塞控制算法</p><ol><li>包括三个部分：慢启动，拥塞避免，快速恢复</li><li>慢启动和拥塞避免是TCP的强制部分，快速恢复是推荐部分，对TCP发送方并非是必需的</li><li>慢启动<ul><li>连接开始的时候, cwnd &#x3D; 1 MSS，并且每当传输报文段首次被确认就增加一个MSS</li><li>故开始以指数方式增加速率，直到产生丢失事件，或者达到某个阈值ssthresh</li><li>如何结束：<ol><li>超时指示的丢包事件：发送方将cwnd &#x3D; 1 MSS，ssthresh（慢启动阈值）&#x3D;cwnd&#x2F;2</li><li>与ssthresh值相关：当到达或超过ssthresh值时线性增长，TCP转移到拥塞避免模式</li><li>收到3个冗余确认后：TCP执行一种快速重传并进入快速恢复状态</li></ol></li></ul></li><li>拥塞避免<ul><li>一旦进入拥塞避免状态，CongWin的值大约是上次遇到拥塞时的一半，即距离阻塞可能并不遥远</li><li>每个RTT只将CongWin的值增加一个MSS</li><li>超时事件以后，迁移到慢启动状态：CongWin值设置为1 MSS，Ssthresh&#x3D; CongWin &#x2F;2 </li><li>收到3个冗余确认后: CongWin减半+3个MSS，Ssthresh&#x3D; CongWin &#x2F;2 ，进入快速恢复阶段</li></ul></li><li>快速恢复<ul><li>对于引起TCP进入快速恢复状态的缺失报文段，每收到一个冗余的ACK，CongWin的值增加一个MSS</li><li>最终，当对丢失的报文段的一个ACK到达时，TCP在降低 CongWin后进入拥塞避免状态，cwnd&#x3D;ssthresh</li><li>如果出现超时事件，迁移到慢启动状态</li></ul></li></ol></li></ol></li></ol><h2 id="第四章、网络层"><a href="#第四章、网络层" class="headerlink" title="第四章、网络层"></a>第四章、网络层</h2><h3 id="4-1、概述"><a href="#4-1、概述" class="headerlink" title="4.1、概述"></a>4.1、概述</h3><ol><li><p>数据平面功能：每台路由器的功能。</p><p>控制平面功能：全网范围决定路由的功能</p></li><li><p>网络层提供的服务和功能</p><p>• 主机通信</p><p>• 虚电路和数据报</p><p>• 转发</p><p>• 选路</p></li><li><p><strong>网络层的功能：转发和路由选择</strong></p><ul><li><p><em>转发：</em>将分组从路由器的一个输入链路接口转移到一个合适的输出链路接口的本地动作</p></li><li><p><em>路由选择：</em>指分组从源到目的地的端到端路径的网络范围动作</p></li></ul></li><li><p><em>转发表：</em>每台路由器有一张</p></li><li><p>控制平面：SDN方法</p><ul><li>一个分离的（通常是远程的）控制器和路由器本地的控制代理 (local control agents，CAs) 交互</li></ul></li><li><p><strong>分组交换机：</strong>一台通用分组交换设备，根据分组首部值，从输入链路接口到输出链路接口传送分组</p><p><strong>链路层交换机：</strong>根据链路层字段值作转发决定的分组交换机</p><p><strong>路由器：</strong>根据网络层字段值作转发决定的分组交换机</p></li><li><p>网络层可能提供的服务：</p><ol><li>确保交付：确保分组到达目的地。</li><li>有序分组交付：按发送顺序到达。</li><li>具有时延上界的确保交付：主机到主机的时延。</li><li>确保最小带宽：当发送主机以低于特定比特率的速率发送比特，分组不会丢失，在一定时延到达。</li><li>确保最大时延抖动：发送方发送两个连续分组的时间间隔与接收到的间隔相同</li></ol></li><li><p>因特网的网络层提供单一服务，称为<strong>尽力而为</strong>服务</p></li></ol><h3 id="4-2、数据报网络"><a href="#4-2、数据报网络" class="headerlink" title="4.2、数据报网络"></a>4.2、数据报网络</h3><ol><li>数据报转发表<ul><li>转发表是由路由选择处理器计算和更新的或者转发表接收来自远程SDN控制器的内容</li><li>用目的地址前缀与转发表的前缀匹配</li><li>存在匹配：向对应链路转发</li><li>不存在匹配：选择“其他”项对应的链路转发</li><li>存在多个匹配：使用最长前缀匹配规则，即向与最长前缀匹配的链路接口转发分组</li><li>一个端系统发送给另一个端系统的一批分组可能在网络中<strong>选择不同的路径，到达的顺序可能不一致</strong></li></ul></li></ol><h3 id="4-3、路由器工作原理"><a href="#4-3、路由器工作原理" class="headerlink" title="4.3、路由器工作原理"></a>4.3、路由器工作原理</h3><ol><li><p>网络层<strong>转发</strong>功能：将分组从路由器的输入链路传送到适当的输出链路</p></li><li><p>路由器体系结构</p></li><li><p>输入端口功能</p><ol><li><p>第一个线路端接模块：将一条物理链路端接到路由器的物理层</p></li><li><p>第二个数据链路处理模块：实现路由器的数据链路层功能；</p></li><li><p>第三个查找与转发模块：实现查找与转发功能，以便分组通过路由器交换结构转发到适当的输出端口；</p></li></ol></li><li><p>查（转发）表方法：</p><ol><li>线性查找</li><li>二分查找</li><li><em>三态内容可寻址内存(TCAM)</em></li><li><em>将最近被访问的表项保存在高速缓存(cache)中</em></li></ol></li><li><p><strong>交换结构</strong></p><ol><li><p>三种交换技术：经内存交换，经总线交换，经互联网络交换</p></li><li><p>经内存交换：</p><ul><li>输入端口与输出端口之间的交换由CPU(选路处理器)控制完成</li></ul></li><li><p>经总线交换：</p><ul><li>输入端口通过一条共享总线将分组直接传送到输出端口，不需要选路处理器的干预</li></ul></li></ol><ul><li>每次只能有一个分组通过总线传送</li></ul><ol start="4"><li><p>经互联网络交换：</p><ul><li><p><em>纵横式交换机：</em>由2<em>n</em> 条总线组成，<em>n</em> 个输入端口与<em>n</em> 个输出端口连接</p></li><li><p>到达输入端口的分组沿水平总线穿行，直至与所希望的输出端口的垂直总线交叉点：</p></li></ul><p>  • 若该条垂直总线空闲，则分组被传送到输出端口；</p><p>  • 否则，该到达的分组被阻塞，必须在输入端口排队</p></li></ol></li><li><p>输出端口（Output ports）</p><ol><li>取出存放在输出端口内存中的分组，并将其传输到输出链路上</li><li>当输出端口的缓冲区溢出时，就会出现延时和丢包</li></ol></li><li><p>输入端口排队</p><ul><li><em>线路前部 HOL (head-of-the-line)阻塞：</em>输入队列中后面的分组被位于线路头的一个分组阻塞(即使输出端口空闲的)，等待通过交换结构发送</li></ul></li><li><p>输出端口排队</p><ul><li>分组丢弃方法：<ol><li>丢弃后到的分组（<em>弃尾</em>）</li><li>删除一个或多个已排队的分组</li></ol></li><li>少量TCP流：缓存数量（B）应当等于平均往返时延（RTT）乘以链路的容量（C）</li><li>大量TCP流（N条）：$B&#x3D;RTT*C&#x2F; \surd{N}$</li></ul></li><li><p><strong>分组调度</strong></p><ol><li><em>先来先服务FCFS</em>：简单</li><li><em>优先权排队</em>：具有优先级<ul><li>根据到达分组的类型，引导到不同优先级的队列中</li><li>优先发送具有最高优先级队列中的分组</li></ul></li><li><em>循环队列规则 RR</em><ul><li>根据到达分组的类型，引导到不同类别的队列中</li><li>循环调度器在这些不同类所对应的队列中轮流提供服务</li></ul></li><li><em>加权公平排队WFQ：</em>在具有排队分组的不同端到端连接之间公平地共享输出链路<ul><li>但是不同类的队列，在每个循环周期中，所获得的服务量并不平等，而是由其权值决定</li></ul></li></ol></li></ol><h3 id="4-4、网际协议（IPv4，DHCP，NAT）"><a href="#4-4、网际协议（IPv4，DHCP，NAT）" class="headerlink" title="4.4、网际协议（IPv4，DHCP，NAT）"></a>4.4、网际协议（IPv4，DHCP，NAT）</h3><ol><li><p>IPv4数据报格式</p><ol><li>一个 IP 数据报由首部和数据两部分组成</li><li>首部的前一部分是<strong>固定长度，共 20 字节，是所有 IP 数据报必须具有的</strong></li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的</li><li>报文段：<ol><li>版本——占 4 位<ul><li>指 IP 协议的版本目前的 IP 协议版本号为 4 (即 IPv4)</li></ul></li><li>首部长度——占 4 位<ul><li>可表示的最大数值是 15 个单位(一个单位为 4 字节)</li><li>因此 IP 的首部长度的<strong>最大值是 60 字节</strong></li></ul></li><li>区分服务——占 8 位<ul><li>用来获得更好的服务在旧标准中叫做服务类型，一般不使用</li></ul></li><li>总长度——占 16 位<ul><li>指<strong>首部和数据之和</strong>的长度，单位为字节</li><li>因此数据报的最大长度为 65535 字节</li><li>总长度必须不超过最大传送单元 MTU</li></ul></li><li>标识(identification) 占 16 位<ul><li>它是一个计数器，用来产生数据报的标识</li></ul></li><li>标志(flag) 占 3 位<ul><li>目前只有前两位有意义</li><li>标志字段的最低位是 <strong>MF</strong> (More Fragment)，MF &#x3D; 1 表示后面“还有分片”。MF &#x3D; 0 表示最后一个分片。</li><li>标志字段中间的一位是 <strong>DF</strong> (Don’t Fragment) ，只有当 DF &#x3D; 0 时才允许分片</li></ul></li><li>片偏移(12 位)<ul><li>指出：较长的分组在分片后某片在原分组中的相对位置</li><li>片偏移以 8 个字节为偏移单位</li></ul></li><li>生存时间(8 位)记为 TTL (Time To Live)<ul><li>数据报在网络中可通过的路由器数的最大值</li><li>值为0则丢弃该数据报</li></ul></li><li>协议(8 位)字段<ul><li>指出此数据报携带的数据用于何种协议，以便目的主机的 IP 层将数据部分上交给哪个处理过程</li></ul></li><li>首部检验和(16 位)字段<ul><li><strong>只检验数据报的首部，不检验数据部分</strong></li><li>这里不采用 CRC 检验码而采用简单的计算方法</li></ul></li><li>源地址和目的地址都各占 4 字节</li><li>选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目</li></ol></li></ol></li><li><p>IP数据报<strong>分片</strong>和重组</p><ol><li><p><strong>MTU</strong>指的是数据链路帧的数据区的最大字节数</p></li><li><p>在添加源地址和目的地址时，还会为该报文段，添加标识字段， 分片后的每个片，都具有相同的源地址和目的地址，以及相同的标识</p></li><li><p>MF&#x3D;0，表示最后一个片</p></li><li><p>通过片偏移字段，标识该片在初始IP数据报中的哪个位置</p><p><strong>注意：</strong>4000数据段字节大小包含数据3980字节和20字节首部</p></li></ol></li><li><p>IP地址</p><ol><li>IP 地址: 分配给主机或路由器接口的标识符</li><li>接口: 主机&#x2F;路由器与物理链路之间的边界<ul><li>路由器有多个接口</li><li>主机可以有多个接口</li><li>每个接口有一个IP地址</li></ul></li><li>IPV4：32个二进制位长（4字节），常用点分十进制表示</li><li>IPV6：128个二进制位长（16字节），常用冒号分隔表示</li></ol></li><li><p>IPv4编址</p><ol><li>32比特的二进制表示和点分十进制表示法</li></ol></li><li><p>IP地址结构</p><ol><li>IP 地址是一种分等级的地址结构，包括两部分：</li></ol><ul><li>网络号：指明主机所在网络的编号</li><li>主机号：主机在网络中的编号</li><li><strong>主机号为全0和全1的两个地址不能使用，用于特殊的目的！</strong></li></ul><ol start="2"><li><p>好处：</p><ol><li>IP 地址管理机构在分配 IP 地址时只分配网络号</li><li>路由器仅根据目的主机所连接的网络号来转发分组</li></ol></li><li><p>特殊IP地址段：</p><ol><li><p>0.0.0.0</p><p>这个地址严格上来说都不是真正意义上的IP地址。主要是用来标识不清楚的网络和主机的。系统遇到无法识别的网络或主机的时候会统一的归纳到这个地址</p></li><li><p>255.255.255.255</p><p>这个地址是受限的广播地址。主要指一个网段内的所有主机</p></li><li><p>127.0.0.1</p><p>这个是预留的一个IP地址，主要是用来识别电脑自己本身的地址。也叫做“localhost”一般用来测试使用的</p></li></ol></li><li><p>同一局域网上的主机或路由器的IP地址中的网络号必须相同。用IP术语来说，<strong>具有相同网络号的局域网，称为子网</strong></p></li><li><p>路由器总是具有两个或两个以上IP地址</p></li><li><p>子网：</p><ul><li>设备接口的IP地址具有同样的网络部分</li><li>没有路由器的介入，物理上能够相互到达</li><li><strong>分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点。这些隔离的网络中的每一个都叫做一个子网</strong></li></ul></li></ol></li><li><p>无类别域间路由( Classless Inlerdomain Routing,CIDR )</p><ol><li>因特网的地址分配策略称为CIDR</li><li>使用斜线记法，又称为CIDR记法来区分<strong>网络前缀和主机号</strong>，即在IP地址后面加上一个斜线“&#x2F;”，斜线后面用一个数字指定网络前缀的长度</li><li>地址格式: a.b.c.d&#x2F;x, 这里 x 是地址网络部分的bit数</li><li>其中&#x2F;x 的记法，也称为<strong>子网掩码</strong></li></ol></li><li><p><strong>子网掩码</strong></p><ol><li>子网掩码用来确定网络前缀和主机地址的长度</li><li>子网掩码长为32位比特，其中的1对应于IP地址中的网络号，而子网掩码中的0对应于主机号</li></ol></li><li><p>路由聚合：<strong>使用单个网路前缀通告多个网络的能力通常称为</strong>地址聚合，也称为路由聚合（书P220）</p></li><li><p><em><strong>子网划分！！！</strong></em></p><p><strong>子网划分总结：</strong></p><ul><li>对于子网划分，建议<strong>先把主机数量最多的子网划分了</strong>，再划分主机数量较小的子网。</li><li>对于子网划分，一个子网能使用的IP的范围，其<strong>起始IP一定是奇数</strong>、其<strong>截止的IP一定是一个偶数</strong></li><li>两个主机号相邻的子网，小序号子网的截止IP和大序号子网的起始IP，中间的差值为3，因为其间间隔了两个主机号为全1和全0的IP</li><li>对于网络号的表示，用于主机的所有bit都要为0</li></ul></li><li><p><strong>动态主机配置协议DHCP（Dynamic Host Configuration Protocol）</strong></p><ol><li><p>自动从一个DHCP服务器得到IP地址</p></li><li><p><strong>DHCP是应用层协议</strong></p></li><li><p>DHCP分配的不仅仅是IP地址，还可分配：</p><p>• 客户的第一跳路由器的地址（网关）</p><p>• DNS服务器的IP地址或域名</p><p>• 子网掩码</p></li><li><p>又被称为plug-and-play（即插即用）协议或zeroconf（零配置）协议</p></li><li><p>DHCP概述：</p><ul><li>主机广播 <strong>DHCP发现报文</strong>，在UDP分组中向端口67发送该报文，使用广播地址255.255.255.255，本机源IP地址0.0.0.0</li><li>DHCP 服务器广播<strong>DHCP提供报文</strong></li><li>主机从一个或多个服务器中选择一个并发送<strong>DHCP请求报文</strong>进行响应</li><li>DHCP 服务器用<strong>DHCP ACK报文</strong>回应确认</li><li>DHCP 终止租用期，发送DHCP RELEASE报文</li></ul></li><li><p>DHCP中继代理(relay agent)：通常为一台路由器</p><ul><li>当 DHCP 中继代理收到主机发送的发现报文后，就以单播方式向 DHCP 服务器转发此报文，并等待其回答。收到 DHCP 服务器回答的提供报文后，DHCP 中继代理再将此提供报文发回给主机</li></ul></li></ol></li><li><p>ISP获取地址块方法——从ICANN获取</p></li><li><p><strong>NAT：网络地址转换</strong></p><ol><li>动机: 对外部网络来讲，本地网络只用一个IP地址</li><li>在NAT转换表中，记录了每个(源IP 地址, 端口号)到 (NAT IP地址, 新端口号) 的对应关系</li><li>16-bit 端口号</li></ol></li><li><p>ICMP(Internet Control Message Protocol，因特网控制报文协议）PPT第四章P146，书P272</p><ol><li>用于主机路由器之间彼此交流网络层信息：<ul><li>差错报告: 不可到达的主机, 网络,端口,协议</li><li>请求&#x2F;应答 (用于ping,traceroute)</li></ul></li><li>位于IP之上：因为ICMP消息是装载在IP分组里的</li></ol></li></ol><h3 id="4-5、IPv6"><a href="#4-5、IPv6" class="headerlink" title="4.5、IPv6"></a>4.5、IPv6</h3><ol><li><p>IPv6首部：</p><ol><li>流量类型:表示流中分组的优先级,类似IPv4中的TOS字段，可用于给出给出一个流中某些数据的优先级</li><li>流标签: 表示分组在同一个 “流”中 (“流”的概念尚未完全定义)</li><li>下一个首部: 表示数据的上层协议，类似IPv4中的协议字段</li><li><strong>定长40字节首部</strong>，选项字段可能出现在“下一个首部”指出的位置上</li></ol></li><li><p>IPv6地址表示：</p><ol><li>冒号十六进制表示法</li></ol><ul><li><p>例如：</p><p>105.220.136.100.255.255.255.255.0.0.18.128.140.10.255.255</p><p>用冒号十六进制表示为：</p><p><strong>69DC:8864:FFFF:FFFF:0:1280:8C0A:FFFF</strong></p></li></ul><ol start="2"><li><p>零压缩表示法</p><ul><li><p>每一块多个前导的0可以省略，一个块全为0可以简写为一个0,多个块为连续0的话可以简写为::</p><p>例如：FF0C:0:0:0:0:0:B1</p><p>零压缩表示为：</p><p><strong>FF0C::B1</strong></p></li></ul></li><li><p>IPv6分为三种地址类型：</p><ol><li>单播地址：一个单播地址对应一个接口，发往单播地址的数据包会被对应的接口接收</li><li>多播(组播)地址：一个组播地址对应一组接口，发往组播地址的数据包会被这组的所有接口接收；目的地为多个主机的数据包在特殊的多播地址上发送</li><li>任播地址：一个任播地址对应一组接口，发往任播地址的数据包会被这组接口的其中一个接收，被哪个接口接收由具体的路由协议确定</li><li><strong>IPv6不使用广播地址，广播地址的功能由多播地址代替</strong></li></ol></li></ol></li><li><p>IPv6与IPv4的不同</p><ol><li><p>分片与重新组装：IPv6 不允许在中间路由器上进行分片与重新组装</p></li><li><p>校验和: 全部去掉，减少每一跳的处理时间</p></li><li><p>选项: 允许, 但是不是标准首部的一部分，而是用下一个首部域指出</p></li><li><p>ICMPv6:新版本的 ICMP</p><p>• 增加消息类型, 例如“分组太大”</p><p>• 多播组管理功能</p></li></ol></li><li><p>IPv4到IPv6的过渡</p><ul><li>双栈：一些路由器具有双重栈 (v6, v4) 能够在两种格式中转换</li><li>隧道: 在穿过IPv4路由器时，IPv6分组作为 IPv4分组的负载</li></ul></li></ol><h3 id="4-6、路由选择算法"><a href="#4-6、路由选择算法" class="headerlink" title="4.6、路由选择算法"></a>4.6、路由选择算法</h3><ol><li>默认路由器：与主机直接相连的路由器，又叫第一跳路由器</li><li><strong>路由算法</strong>：是确定一个分组从源路由器到目的路由器所经路径的算法</li><li>路由算法分类：<ol><li>集中式（全局）选路算法，分散式路由选择算法</li><li>静态选路算法，动态选路算法</li></ol></li><li><em><strong>链路状态路由选择算法！！！</strong></em><ol><li>转发表：存放从源节点到每个目的节点的最低费用路径上的下一跳节点</li><li>所有迭代中需要搜寻的节点总数为n(n+1)&#x2F;2</li><li>算法复杂性为n平方阶序O(n^2^)</li></ol></li></ol><h3 id="4-7、层次选路"><a href="#4-7、层次选路" class="headerlink" title="4.7、层次选路"></a>4.7、层次选路</h3><ol><li><p><em>自治系统(Autonomous System) AS：</em> </p><ul><li>按区域划分的系统。每个AS由一组在相同管理控制下的路由器组成。</li><li>同一个AS内的路由器可运行相同的选路算法，且拥有相互之间的信息</li></ul></li><li><p>层次选路：</p><p>➢将一个大的系统划分成若干小系统（自治系统），</p><p>➢按区域或自治系统的形式组织路由器。</p><p>➢自治系统之间再互连</p></li><li><p><em>网关路由器（gateway router）：</em>互连各AS，负责转发目的地在本AS之外的分组（将本AS内的分组转发到另一个AS的路由器）</p></li><li><p>当一个AS知道从一个相邻的AS可以到达目的地，向某些他的相邻AS通告该选路信息</p></li><li><p>因特网中的路由选择</p><ol><li><p>AS内部选路协议：</p><p>✓ <em>RIP选路信息协议：</em>基于距离向量的路由协议</p><p>✓ <em>OSPF开放最短路径优先：</em>采用Dijkstra最短费用路径算法，是一种链路状态协议</p></li><li><p>AS间选路协议：</p><p>✓ <em>BGP边界网关协议：</em>基于距离向量的路由协议。相邻BGP路由器相互交换路径信息</p></li></ol></li><li><p><strong>OSPF</strong></p><ol><li>用链路状态算法</li><li>每个router都以洪泛的方式广播OSPF通告，OSPF通告里为每个邻居路由器设一个表项</li><li>通告会散布到整个自治系统</li><li><strong>OSPF信息直接通过 IP传输 (不是 TCP 或 UDP）</strong></li><li>优点：<ol><li>安全</li><li>多条相同开销的路径</li><li>对单播与多播路由选择的综合支持</li><li>支持在单个AS中的层次结构</li></ol></li></ol></li><li><p><strong>Internet 域间选路: 边界网关协议BGP</strong></p><ol><li><p>BGP (Border Gateway Protocol)：事实上的标准</p></li><li><p>路由器对（BGP对等方）通过<strong>TCP连接</strong>来交换选路信息：BGP 会话</p></li><li><p><strong>在BGP中，目的地不是主机地址，而是CIDR化前缀</strong></p></li><li><p>eBGP：跨越两个AS的BGP连接</p></li><li><p>iBGP：在相同AS中的两台路由器之间的BGP会话</p></li><li><p>确定最好的路由：</p><ol><li>AS-PATH: 包含了前缀的通告已经通告过的那些AS</li><li>NEXT-HOP: AS-PATH起始的路由器接口的IP地址（可能存在多条从当前AS到达下一个AS的链路）</li></ol></li><li><p>BGP路由选择：</p><p>排除规则（应用排除规则直到有一条留下）</p><p>• 本地偏好值属性: 具有最高偏好值的路由被选择</p><p>• 最短AS-PATH的路由 （使用AS跳数）</p><p>• 最靠近 NEXT-HOP路由器的路由 : 热土豆路由（AS内部路由算</p><p>法决定）。</p><p>• 其他标准</p></li><li><p>IP任播</p><ol><li>BGP还常被用于实现IP任播（ anycast ） 服务</li><li>所谓任播，也叫“选播”，就是对具有相同IP地址的一组服务器中的任意一台，发送消息</li></ol></li><li><p>为什么AS内选路和AS间选路采用不同的协议 ? </p><p>策略: </p><p>• AS间: 管理员想控制本AS内产生的通信流怎样选路，以及什么通信流穿过自己的网络</p><p>• AS内:单个管理者, 因此不需要策略</p></li></ol></li></ol><h3 id="4-8、SDN"><a href="#4-8、SDN" class="headerlink" title="4.8、SDN"></a>4.8、SDN</h3><ol><li><p>软件定义网络（SDN，SoftwareDefinedNetwork）源自美国斯坦福大学CLeanState研究组提出的一种新型网络创新架构，可通过软件编程的形式定义和控制网络，具有控制平面和转发平面分离及开放性可编程的特点</p></li><li><p>SDN的核心思想是建立一个通用转发体系——每个交换设备包含一个<strong>流表(flow table)</strong>.。流表由一个逻辑上中心化的控制器（远程控制器）来计算和分发 </p></li><li><p>基于目的转发的两个步骤：<strong>匹配+动作</strong></p></li><li><p>通用转发：通用意义上的匹配加动作</p><p>➢ 匹配：根据协议中多个首部中的字段进行匹配。 </p><p>➢ 动作：包括转发、丢弃、修改、负载均衡、向特定服务器转发等不同动作</p></li><li><p>SDN体系特征</p><ol><li>基于流的转发</li><li>数据平面与控制平面分离</li><li>网络控制功能：位于数据平面交换机外部</li><li>可编程的网络</li></ol></li><li><p>OpenFlow</p><ol><li>OpenFlow网络由 OpenFlow网络设备（OpenFlow Switch）和控制器（OpenFlow Controller）通过OpenFlow通道（OpenFlow Channel）组成</li></ol></li></ol><h2 id="第五章、链路层"><a href="#第五章、链路层" class="headerlink" title="第五章、链路层"></a>第五章、链路层</h2><h3 id="5-1、概述"><a href="#5-1、概述" class="headerlink" title="5.1、概述"></a>5.1、概述</h3><ol><li><em>节点 (node)：</em>主机、交换机和路由器、WiFi接入点等</li><li><em>链路(link)：</em>连接相邻节点的通信信道</li><li>数据链路层的职责：将分组通过一个链路，从一个节点传输到临近的另一个节点</li><li>交换的数据单元称为*帧 (frame)*，封装了一个网络层的数据报</li><li>链路层提供的服务<ol><li><strong>封装成帧 (framing)</strong></li><li><strong>链路访问</strong></li><li><strong>在相邻节点之间可靠交付</strong></li><li><strong>差错检查(error detection)</strong></li><li><strong>错误纠正(error correction)</strong></li><li><strong>流量控制(flow control)</strong></li></ol></li></ol><h3 id="5-2、差错检测与纠正"><a href="#5-2、差错检测与纠正" class="headerlink" title="5.2、差错检测与纠正"></a>5.2、差错检测与纠正</h3><ol><li>三种主要差错检测技术<ol><li><strong>奇偶校验</strong>：最基本的方法</li><li><strong>Internet校验和</strong>：常用于运输层</li><li><strong>循环冗余检测</strong>：常用于链路层</li></ol></li><li>奇偶校验<ol><li>一比特奇偶校验<ul><li>偶校验：发现奇数个“1”，至少有一个比特发生差错（奇数个比特差错）</li><li>奇校验：发现偶数个“1”，至少有一个比特发生差错</li><li>可以查出任意奇数个错误，但不能发现偶数个错误</li></ul></li><li>二维奇偶校验<ul><li>可以检测并纠正单个比特差错（数据或校验位中）</li><li>能够检测(但不能纠正)分组中任意两个比特的差错</li></ul></li></ol></li><li>循环冗余检测<strong>CRC (cyclic redundancy check)</strong><ol><li>特点：能检测小于 r+1 位的突发差错、任何奇数个差错，长度大于r+1比特的突发差错以概率 1 -0. 5^r^ 被检测到</li></ol></li></ol><h3 id="5-3、多路访问链路和协议"><a href="#5-3、多路访问链路和协议" class="headerlink" title="5.3、多路访问链路和协议"></a>5.3、多路访问链路和协议</h3><ol><li><p>两种访问链路：</p><ol><li>点对点链路：链路两端各一个节点。一个发送和一个接收。如点对点协议PPP</li><li>广播链路： 多个节点连接到一个共享的广播信道</li></ol></li><li><p>冲突（collide）：两个以上的节点同时传输帧，使接收方收不到正确的帧（所有冲突的帧都受损丢失）</p></li><li><p>三类多路访问协议：</p><ol><li>信道划分协议<ul><li>把信道划分为小“片” (时隙) </li><li>给节点分配专用的小“片”</li></ul></li><li>随机访问协议<ul><li>不划分信道，允许冲突</li><li>能从冲突中“恢复”</li></ul></li><li>轮流协议<ul><li>通过轮流访问信道避免冲突，要发送的节点越多轮流时间越长</li></ul></li></ol></li><li><p>信道划分协议</p><ol><li>主要有TDMA、FDMA、CDMA三种</li><li>时分多路访问TDMA (time division multiple access)<ul><li>将时间划分为<em>时间帧</em>，每个时间帧再划分为<em>N个时隙</em>（长度保证发送一个分组），分别分配给<em>N</em>个节点。每个节点只在固定分配的时隙中传输</li></ul></li><li>频分多路访问FDMA (frequency division multiple access)<ul><li>将总信道带宽 R b&#x2F;s划分为 N 个较小信道（频段，带宽为R&#x2F;N），分别分配给N 个节点</li></ul></li><li>码分多路访问CDMA (frequency division multiple access)<ul><li>每个节点分配一个唯一的编码</li><li>每个节点用它唯一的编码来对它发送的数据进行编码</li><li>允许多个节点“共存” ，信号可叠加，即可以同时传输数据而无冲突</li></ul></li></ol></li><li><p>随机访问协议</p><ol><li><p>ALOHA</p><ol><li><p>时隙ALOHA</p><ul><li>当节点有新的帧要发送，需等到下一个时隙开始，才传输整个帧</li><li><em>无冲突：</em>节点成功传输帧</li><li><em>有冲突：</em>节点检测到冲突后，以概率<em>p</em>在后续的每一个时隙重传该帧，直到成功</li></ul></li><li><p>纯 ALOHA</p><ul><li><p>帧一到达，立即传输</p></li><li><p>如果与其他帧产生冲突，在该冲突帧传完之后：</p><p>• 以概率<em>p</em>立即重传该帧；</p><p>• 或等待一个帧的传输时间，再以概率<em>p</em> 传输该帧，或者以概率1-<em>p</em> 等待另一个帧的时间</p></li></ul></li></ol></li><li><p>CSMA（载波侦听多路访问）</p><ol><li><strong>载波侦听</strong>：某个节点在发送之前，先监听信道</li></ol></li><li><p>带冲突检测的CSMA(CSMA&#x2F;CD)</p><ol><li><p>增加“载波侦听”和“冲突检测”两个规则</p></li><li><p>基本原理： 传送前侦听</p><p>• 信道忙：延迟传送</p><p>• 信道闲：传送整个帧</p></li><li><p>发送同时进行冲突检测：一旦检测到冲突就立即停止传输， 尽快重发</p></li></ol></li></ol></li><li><p>轮流协议</p><ol><li>轮询(polling)协议<ul><li>主节点“邀请”从节点依次传送</li></ul></li><li>令牌传递(token passing)协议<ul><li>控制令牌顺序从一个节点传递到下一个节点</li></ul></li></ol></li><li><p><strong>多路访问控制协议的总结</strong></p><ol><li><strong>信道划分</strong>：时分，频分，码分</li><li><strong>随机接入：</strong><ul><li>ALOHA, S-ALOHA, CSMA, CSMA&#x2F;CD</li><li>载波侦听：在某些技术中容易实现(有线)，在有些技术中比较困难(无线) </li><li>CSMA&#x2F;CD used in Ethernet</li><li>CSMA&#x2F;CA used in 802.11</li></ul></li><li><strong>轮流</strong><ul><li>来自中心站的轮询</li><li>令牌传递</li></ul></li></ol></li></ol><h3 id="5-4、交换局域网（ARP）"><a href="#5-4、交换局域网（ARP）" class="headerlink" title="5.4、交换局域网（ARP）"></a>5.4、交换局域网（ARP）</h3><ol><li><p>局域网：Local Area Network ( LAN )</p></li><li><p><strong>多址访问协议</strong>广泛应用于局域网</p></li><li><p>局域网按拓扑结构进行分类：星形网、环形网、总线网、树形网和网状网</p></li><li><p>基于<strong>随机访问的CSMA&#x2F;CD</strong>广泛应用于局域网</p></li><li><p><strong>链路层寻址和ARP</strong></p><ol><li><p>每个接口有网络层地址和链路层地址</p></li><li><p>链路层地址：MAC地址，用于把数据帧从一个节点传送到另一个节点(同一网络中)</p></li><li><p><strong>MAC地址</strong></p><ol><li>节点“网卡”本身所带的地址（唯一）</li><li><strong>MAC地址长度通常为6字节(48比特)，共2^48^个。 1A-2F-BB-76-09-AD</strong></li><li>6字节地址用16进制表示，每个字节表示为一对16进制数</li><li>网卡的MAC地址是永久的</li><li><strong>MAC 地址是平面（扁平）结构</strong>带有同一网卡的节点，在任何网络中都有同样的MAC地址</li></ol></li><li><p>MAC地址识别</p><ol><li>广播信道的局域网中，一个节点发送的帧，在信道上广播传输，其他节点都可能收到该帧</li><li><strong>发送适配器</strong>：将目的MAC地址封装到帧中，并发送。所有其他适配器都会收到这个帧</li><li><strong>接收适配器</strong>：检查帧的目的MAC地址是否与自己MAC地址相匹配：<ul><li>匹配：接收该帧，取出数据报，并传递给上层。</li><li>不匹配：丢弃该帧</li></ul></li><li><strong>广播帧：发送给所有节点的帧 。全1地址：FF-FF-FF-FF-FF-FF</strong></li></ol></li><li><p><strong>地址转换：主机名 → IP地址 → MAC地址</strong></p><ul><li><p>DNS域名系统：将主机名解析到IP地址。 </p><p>• DNS为在因特网中任何地方的主机解析主机名</p></li><li><p>ARP地址解析协议：将IP地址解析到MAC地址。 </p><p>• ARP只为在同一个LAN上的节点解析IP地址</p></li></ul></li></ol></li><li><p><strong>ARP：地址解析协议</strong></p><ol><li><p><em>ARP表:</em> 局域网上的每个节点(主机、路由器)都有这个表</p><ul><li>为某些局域网节点进行IP&#x2F;MAC地址映射：**&lt; IP address; MAC address; TTL&gt;**</li><li>TTL (存活时间): 地址映射将被删除的时间（通常为20分钟）</li></ul></li><li><p>查询过程：</p><p>A 希望发送数据报给 B 但B的MAC地址不在A的ARP映射表中</p><p>A广播包含B的IP地址的ARP查询分组 </p><p>​• 目的MAC地址&#x3D; FF-FF-FF-FF-FF-FF</p><p>​• 在局域网上的所有机器都能收到ARP查询</p><p>​• 每个适配器把该帧中的ARP查询分组向上传递给ARP模块，并由ARP模块检查是否与查询IP匹配</p><p>B收到ARP分组，回给A一个带有B的MAC地址的分组 </p><p>​• ARP响应分组单播发送给A的MAC地址</p></li><li><p><strong>ARP协议是跨越链路层和网络层两边的协议</strong></p></li></ol></li><li><p>以太网(Ethernet)</p><ol><li><p>到目前为止，以太网是最为著名的有线局域网技术</p></li><li><p>物理拓扑结构：星形(star)目前流行</p></li><li><p>以太网帧结构：</p><ol><li>前同步码（8字节）<ul><li>前7字节是“10101010”，最后一个字节是“10101011”。 </li><li>使接收方和发送方的时钟同步，接收方一旦收到连续的8字节前同步码，可确定有帧传过来。</li><li>前同步码是“无效信号”，接收方收到后删除，不向上层传。</li><li><strong>CRC的校验范围不包括前同步码</strong></li></ul></li><li>源、目的MAC地址(各6字节)</li><li>类型字段(2 字节)<ul><li>以太网可以“多路复用”（支持）多种网络层协议。通过“类型”字段区分</li></ul></li><li>数据字段(46～1500 字节)<ul><li><strong>以太网的最大传输单元MTU是1500字节</strong></li><li><strong>若IP数据报超过1500字节，必须将该数据报分片</strong></li><li>最小长度是46字节</li><li>如果IP数据报小于46字节，必须填充为46字节。接收方网络层去除填充内容</li></ul></li><li>循环冗余检测CRC(4字节)<ul><li>接收主机进行CRC校验：接收主机对收到的帧校验。若计算结果，<strong>余数不等于0</strong>(CRC校验失败)，该帧有差错</li></ul></li></ol></li></ol></li><li><p>CSMA&#x2F;CD:以太网的多路访问协议</p><ol><li><p><em>未使用时隙：</em>适配器可以在任何时刻开始传输</p></li><li><p><em>使用载波侦听：</em>当一个节点要发送数据时，首先监听信道，看是否有载波。</p><ul><li><p>如果信道空闲，则发送数据。</p></li><li><p>如果信道忙，则继续对信道进行监听（1－坚持CSMA）。一旦发现空闲，便立即发送</p></li></ul></li><li><p><em>使用冲突检测：</em>如果在发送过程中检测到碰撞，则停止自己的正常发送，转而发送一短暂的干扰信号jam，强化冲突，使其它站点都能知道出现了冲突</p></li><li><p><em>重传：</em>发送了干扰信号后，退避一随机时间，重新尝试发送</p></li><li><p><em>基本后退时间：</em>以512 比特时间为单位；</p><p>✓<em>第n次冲突后退让时间<strong>：</strong>K</em> × 512 比特时间</p><p><em>K</em>与冲突次数有关，是{ 0～2<em>m</em>-1}之间的一个随机整数。 <em>m &#x3D;</em> min(<em>n</em>，10)</p></li></ol></li><li><p>以太网向网络层提供的服务：</p><ol><li>无连接服务<ol start="2"><li>不可靠的服务</li></ol></li><li>以太网的MAC协议：使用无时隙的CSMA&#x2F;CD协议</li></ol></li></ol><h3 id="5-5、链路层交换机"><a href="#5-5、链路层交换机" class="headerlink" title="5.5、链路层交换机"></a>5.5、链路层交换机</h3><ol><li><p><strong>集线器Hub</strong>：集线器本质上是物理层的中继器</p></li><li><p>互联网络中所有的网段属于同一个<em>冲突域</em></p></li><li><p>每个交换机有一个交换机转发表，其中每个条目：(主机的MAC地址，到达主机的端口，时戳)类似于路由表</p></li><li><p>通过自学习建立转发表中的条目</p></li><li><p><em>过滤(filtering)：</em>交换机判断一个帧是应该转发到某个接口还是丢弃</p></li><li><p><em>转发(forward)：</em>交换机决定一个帧应该被指向哪个接口，并引导到该接口</p></li><li><p>自学习：交换机会学习通过哪些端口可以到达哪些主机。即交换机表可以自动地、动态地和自主地建立</p></li><li><p><strong>交换机是即插即用设备 (plug-and-play device)</strong></p></li><li><p>路由器与交换机比较</p><ol><li>两者都是存储转发设备:<ul><li>路由器: 网络层设备(检查网络层头部)</li><li>交换机：链路层设备(检查链路层头部)</li></ul></li><li>两者都有转发表<ul><li>路由器：使用<strong>路由算法</strong>计算转发表，基于IP地址转发</li><li>交换机：通过<strong>洪泛、自学习</strong>来学习转发表，基于MAC地址转发</li></ul></li></ol></li><li><p>交换机优缺点：</p><ol><li><p>✓即插即用：不需网络管理员干预；</p><p>✓较高的分组过滤和转发率：</p><p>✓拓扑结构为一棵生成树。</p><p>✓可能产生“广播风暴”：</p><p>某台主机失控，并传输无穷的以太网广播帧流，交换机将转发所有这些帧，导致整个以太网的崩溃</p></li></ol></li></ol><h3 id="5-6、VLAN虚拟局域网"><a href="#5-6、VLAN虚拟局域网" class="headerlink" title="5.6、VLAN虚拟局域网"></a>5.6、VLAN虚拟局域网</h3><ol><li>支持VLAN的交换机允许经一个单一的物理局域网基础设施定义多个虚拟局域网</li><li>基于端口、MAC地址、IP地址、网络层协议等不同的方式划分 VLAN</li><li>基于端口的VLAN：<ol><li><em>流量隔离:</em> 来至端口1-8的流量，只能到达端口1-8 <ul><li>每个VLAN形成独立的广播域</li></ul></li><li>端口动态的分配: 一个端口可以由管理员动态的分配给一个VLAN，只需通过软件进行配置</li><li><strong>VLAN间的转发: 只能通过VLAN间的路由实现</strong><ul><li>在实践中厂商把交换机加路由器包含在一台设备中，就是所谓的三层交换机</li></ul></li><li><em>干线端口(trunk port):</em> 用于在多个物理交换机之间交换帧</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2022/12/12/test/"/>
      <url>/2022/12/12/test/</url>
      
        <content type="html"><![CDATA[<h1 id="hello"><a href="#hello" class="headerlink" title="hello"></a>hello</h1>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
