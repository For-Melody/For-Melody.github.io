<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL | Melodyの博客</title><meta name="author" content="Melody"><meta name="copyright" content="Melody"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MySQL面试数据库基础1、为什么不推荐使用外码键？ 增加了复杂性： a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦 增加了额外工作： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="https://for-melody.github.io/2022/12/15/MySQL/index.html">
<meta property="og:site_name" content="Melodyの博客">
<meta property="og:description" content="MySQL面试数据库基础1、为什么不推荐使用外码键？ 增加了复杂性： a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦 增加了额外工作： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://pictrue-bed.pages.dev/img/a78c8de3a671c5b31eff23ef4087b211.jpg">
<meta property="article:published_time" content="2022-12-15T11:00:00.000Z">
<meta property="article:modified_time" content="2022-12-15T10:58:43.109Z">
<meta property="article:author" content="Melody">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pictrue-bed.pages.dev/img/a78c8de3a671c5b31eff23ef4087b211.jpg"><link rel="shortcut icon" href="https://pictrue-bed.pages.dev/img/雪人.png"><link rel="canonical" href="https://for-melody.github.io/2022/12/15/MySQL/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-15 18:58:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://pictrue-bed.pages.dev/img/102548934_p0_master1200.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://pictrue-bed.pages.dev/img/a78c8de3a671c5b31eff23ef4087b211.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Melodyの博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-12-15T11:00:00.000Z" title="发表于 2022-12-15 19:00:00">2022-12-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-12-15T10:58:43.109Z" title="更新于 2022-12-15 18:58:43">2022-12-15</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>81分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="MySQL面试"><a href="#MySQL面试" class="headerlink" title="MySQL面试"></a>MySQL面试</h1><h1 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h1><h2 id="1、为什么不推荐使用外码键？"><a href="#1、为什么不推荐使用外码键？" class="headerlink" title="1、为什么不推荐使用外码键？"></a>1、为什么不推荐使用外码键？</h2><ul>
<li><strong>增加了复杂性：</strong> a. 每次做DELETE 或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦</li>
<li><strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li>
<li><strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li>
</ul>
<p>外码键的<strong>好处</strong>：</p>
<ul>
<li><p>保证了数据库数据的一致性和完整性；</p>
</li>
<li><p>级联操作方便，减轻了程序代码量</p>
</li>
</ul>
<h2 id="2、范式"><a href="#2、范式" class="headerlink" title="2、范式"></a>2、范式</h2><h3 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h3><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式</p>
<blockquote>
<p><strong>如果关系表中的属性不可再细分且属性列不可重复，该关系满足第1范式</strong></p>
</blockquote>
<h3 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h3><p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键</p>
<blockquote>
<p><strong>第二范式要求关系表中所有数据都要和关系表的主键有完全函数依赖（即属性不能只和主键有部分依赖关系）</strong></p>
</blockquote>
<h3 id="3NF-第三范式"><a href="#3NF-第三范式" class="headerlink" title="3NF(第三范式)"></a>3NF(第三范式)</h3><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求</p>
<blockquote>
<p><strong>每一个非主属性既不部分依赖于码也不传递依赖于码</strong></p>
</blockquote>
<p>总：</p>
<ul>
<li>1NF：属性不可再分。</li>
<li>2NF：1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</li>
<li>3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖</li>
</ul>
<h2 id="3、ACID"><a href="#3、ACID" class="headerlink" title="3、ACID"></a>3、ACID</h2><ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</li>
</ol>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的</strong></p>
<h2 id="4、并发事务的问题"><a href="#4、并发事务的问题" class="headerlink" title="4、并发事务的问题"></a>4、并发事务的问题</h2><ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</li>
</ul>
<hr>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h1 id="1、基础架构"><a href="#1、基础架构" class="headerlink" title="1、基础架构"></a>1、基础架构</h1><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/javaguide/13526879-3037b144ed09eb88.png"></p>
<p>MySQL 主要由下面几部分构成：</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）</li>
</ul>
<blockquote>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件</p>
<p><strong>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</strong></p>
</blockquote>
<ul>
<li><p><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</p>
</li>
<li><p><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</p>
</li>
<li><p><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</p>
</li>
<li><p><strong>日志模块：</strong>在server层是binlog归档日志模块</p>
</li>
<li><p><strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎</p>
</li>
<li><p><strong>查询语句的执行流程如下：权限校验（如果命中缓存）—&gt;查询缓存—&gt;分析器—&gt;优化器—&gt;权限校验—&gt;执行器—&gt;引擎</strong></p>
</li>
<li><p><strong>更新语句执行流程如下：分析器—-&gt;权限校验—-&gt;执行器—&gt;引擎—redo log(prepare 状态)—&gt;binlog—&gt;redo log(commit状态)</strong></p>
</li>
</ul>
<h2 id="MyISAM与InnoDB"><a href="#MyISAM与InnoDB" class="headerlink" title="MyISAM与InnoDB"></a>MyISAM与InnoDB</h2><p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎</p>
<p>MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复</p>
<p><strong>MyISAM与InnoDB的对比：</strong></p>
<p>1.<strong>是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code></p>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能</p>
<p><strong>6.索引实现不一样</strong></p>
<p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录</p>
<h1 id="2、MySQL事务"><a href="#2、MySQL事务" class="headerlink" title="2、MySQL事务"></a>2、MySQL事务</h1><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行</strong></p>
<h2 id="1-ACID"><a href="#1-ACID" class="headerlink" title="1.ACID"></a><strong>1.ACID</strong></h2><ol>
<li><strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li>
<li><strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性</strong>（<code>Durabilily</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响</li>
</ol>
<blockquote>
<p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的</strong></p>
</blockquote>
<h2 id="2-并发事务的问题"><a href="#2-并发事务的问题" class="headerlink" title="2.并发事务的问题"></a>2.并发事务的问题</h2><ul>
<li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A&#x3D;20，事务 2 也读取 A&#x3D;20，事务 1 修改 A&#x3D;A-1，事务 2 也修改 A&#x3D;A-1，最终结果 A&#x3D;19，事务 1 的修改被丢失。</li>
<li><strong>不可重复读（Unrepeatable read）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</li>
<li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读</li>
</ul>
<p><strong>不可重复读和幻读有什么区别呢？</strong></p>
<ul>
<li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li>
<li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li>
</ul>
<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样</p>
<p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读</p>
<h2 id="3-SQL事务隔离级别"><a href="#3-SQL事务隔离级别" class="headerlink" title="3.SQL事务隔离级别"></a>3.SQL事务隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</li>
<li><strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读</li>
</ul>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong></p>
<p>InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别</p>
<h3 id="解决幻读的方法"><a href="#解决幻读的方法" class="headerlink" title="解决幻读的方法"></a>解决幻读的方法</h3><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p>
<ol>
<li>将事务隔离级别调整为 <code>SERIALIZABLE</code> </li>
<li>在可重复读的事务级别下，给事务操作的这张表添加表锁</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code></li>
<li>（在InnoDB中）在可重复读隔离级别下使用MVCC</li>
</ol>
<h2 id="4-MySQL-的隔离级别是基于锁实现的吗？"><a href="#4-MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="4.MySQL 的隔离级别是基于锁实现的吗？"></a>4.MySQL 的隔离级别是基于锁实现的吗？</h2><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p>
<p>SERIALIZABLE 隔离级别，是通过锁来实现的。除了 SERIALIZABLE 隔离级别，其他的隔离级别都是基于 MVCC 实现。</p>
<p>不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读</p>
<h1 id="3、MySQL锁"><a href="#3、MySQL锁" class="headerlink" title="3、MySQL锁"></a>3、MySQL锁</h1><p><img src="https://static001.geekbang.org/infoq/b0/b06a9b49cfa61b884ff23185aadce275.webp?x-oss-process=image/resize,p_80/format,png"></p>
<h2 id="1-表级锁和行级锁"><a href="#1-表级锁和行级锁" class="headerlink" title="1.表级锁和行级锁"></a>1.表级锁和行级锁</h2><p><strong>表级锁和行级锁对比</strong> ：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM 和 InnoDB 引擎都支持表级锁</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁</li>
</ul>
<h2 id="2-行级锁的使用有什么注意事项？"><a href="#2-行级锁的使用有什么注意事项？" class="headerlink" title="2.行级锁的使用有什么注意事项？"></a>2.行级锁的使用有什么注意事项？</h2><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。<strong>这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</strong></p>
<h2 id="3-共享锁和排他锁"><a href="#3-共享锁和排他锁" class="headerlink" title="3.共享锁和排他锁"></a>3.共享锁和排他锁</h2><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p>
<ul>
<li><strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong> ：又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">S 锁</th>
<th align="left">X 锁</th>
</tr>
</thead>
<tbody><tr>
<td align="left">S 锁</td>
<td align="left">不冲突</td>
<td align="left">冲突</td>
</tr>
<tr>
<td align="left">X 锁</td>
<td align="left">冲突</td>
<td align="left">冲突</td>
</tr>
</tbody></table>
<p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 共享锁</span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"># 排他锁</span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure>

<h2 id="4-意向锁"><a href="#4-意向锁" class="headerlink" title="4.意向锁"></a>4.意向锁</h2><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢？一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁</p>
<p>意向锁是表级锁，共有两种：</p>
<ul>
<li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li>
<li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li>
</ul>
<p>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享 &#x2F; 排他锁之前，InooDB 会先获取该数据行所在数据表的对应意向锁</p>
<p>意向锁之间是互相兼容的。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody><tr>
<td>IS 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody></table>
<p>意向锁和共享锁和排它锁互斥（<strong>这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥</strong>）。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody><tr>
<td>S 锁</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>X 锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody></table>
<h2 id="5-InnoDB-的行锁"><a href="#5-InnoDB-的行锁" class="headerlink" title="5.InnoDB 的行锁"></a>5.InnoDB 的行锁</h2><p>MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><p><strong>记录锁（Record Lock）</strong></p>
</li>
<li><p><strong>间隙锁（Gap Lock）</strong> </p>
</li>
<li><p><strong>临键锁（Next-key Lock）</strong></p>
</li>
</ul>
<p>InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：</p>
<ul>
<li><strong>快照读</strong>（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</li>
<li><strong>当前读</strong> （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读</li>
</ul>
<h3 id="5-1、记录锁（Record-Lock）"><a href="#5-1、记录锁（Record-Lock）" class="headerlink" title="5.1、记录锁（Record Lock）"></a>5.1、记录锁（Record Lock）</h3><p>也被称为记录锁，属于单个行记录上的锁</p>
<h3 id="5-2、间隙锁（Gap-Lock）"><a href="#5-2、间隙锁（Gap-Lock）" class="headerlink" title="5.2、间隙锁（Gap Lock）"></a>5.2、间隙锁（Gap Lock）</h3><p>锁定一个范围，不包括记录本身（<strong>只出现在可重复读的事务隔离级别中</strong>）</p>
<blockquote>
<p>间隙锁的<strong>例外</strong>：</p>
<ol>
<li>如果索引列是唯一索引，那么只会锁住这条记录(只加行锁)，而不会锁住间隙。</li>
<li>对于联合索引且是唯一索引，如果 where 条件只包括联合索引的一部分，那么依然会加间隙锁</li>
</ol>
</blockquote>
<h3 id="5-3、临界锁（Next-Key-Lock）"><a href="#5-3、临界锁（Next-Key-Lock）" class="headerlink" title="5.3、临界锁（Next-Key Lock）"></a>5.3、临界锁（Next-Key Lock）</h3><p>Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁</p>
<blockquote>
<ol>
<li><strong>临键锁锁定区间和查询范围后匹配值很重要，如果后匹配值存在，则只锁定查询区间，否则锁定查询区间和后匹配值与它的下一个值的区间</strong></li>
<li><strong>临界锁是相互兼容的，因此可能造成死锁</strong></li>
</ol>
</blockquote>
<h3 id="5-4、插入意向锁-Insert-Intention-lock"><a href="#5-4、插入意向锁-Insert-Intention-lock" class="headerlink" title="5.4、插入意向锁( Insert Intention lock )"></a>5.4、插入意向锁( Insert Intention lock )</h3><p><strong>插入意向锁</strong>是在插入一条记录行前，由 <strong>INSERT</strong> 操作产生的一种<code>间隙锁</code>。该锁用以表示插入<strong>意向</strong>，当多个事务在<strong>同一区间</strong>（gap）插入<strong>位置不同</strong>的多条数据时，事务之间<strong>不需要互相等待</strong>。假设存在两条值分别为 4 和 7 的记录，两个不同的事务分别试图插入值为 5 和 6 的两条记录，每个事务在获取插入行上独占的（排他）锁前，都会获取（4，7）之间的<code>间隙锁</code>，但是因为数据行之间并不冲突，所以两个事务之间并<strong>不会产生冲突</strong>（阻塞等待）</p>
<p>插入意向锁的特性可分为两部分：</p>
<ol>
<li><code>插入意向锁</code>是一种特殊的<code>间隙锁</code> —— <code>间隙锁</code>可以锁定<strong>开区间</strong>内的部分记录。</li>
<li><code>插入意向锁</code>之间互不排斥，所以即使多个事务在同一区间插入多条记录，只要记录本身（<code>主键</code>、<code>唯一索引</code>）不冲突，那么事务之间就不会出现<strong>冲突等待</strong></li>
</ol>
<blockquote>
<p>需要强调的是，虽然<code>插入意向锁</code>中含有<code>意向锁</code>三个字，但是它并不属于<code>意向锁</code>而属于<code>间隙锁</code>，因为<code>意向锁</code>是<strong>表锁</strong>而<code>插入意向锁</code>是<strong>行锁</strong></p>
</blockquote>
<p><strong>为什么要使用插入意向锁？</strong></p>
<p>我的理解是直接使用间隙锁的话，对于锁住的区间，不同事务想要插入的位置可能不同，在这种情况下会造成频繁的<strong>阻塞等待</strong>，<strong>插入的并发性</strong>非常差，而加入插入意向锁之后就能解决并发插入的问题</p>
<p><strong>插入意向锁小结：</strong></p>
<ol>
<li><strong>MySql InnoDB</strong> 在 <code>Repeatable-Read</code> 的事务隔离级别下，使用<code>插入意向锁</code>来控制和解决并发插入</li>
<li><code>插入意向锁</code>是一种特殊的<code>间隙锁</code></li>
<li><code>插入意向锁</code>在<strong>锁定区间相同</strong>但<strong>记录行本身不冲突</strong>的情况下<strong>互不排斥</strong></li>
</ol>
<h2 id="6-当前读和快照读区别"><a href="#6-当前读和快照读区别" class="headerlink" title="6.当前读和快照读区别"></a>6.当前读和快照读区别</h2><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">SELECT</span> ... LOCK <span class="keyword">IN</span> SHARE MODE</span><br></pre></td></tr></table></figure>

<p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p>
<p>快照读的情况下，如果读取的记录正在执行 UPDATE&#x2F;DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>
<p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>
<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>
</ul>
<p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p>
<p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p>
<p>当前读的一些常见 SQL 语句类型如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 对读的记录加一个X锁</span><br><span class="line">SELECT...FOR <span class="keyword">UPDATE</span></span><br><span class="line"># 对读的记录加一个S锁</span><br><span class="line">SELECT...LOCK <span class="keyword">IN</span> SHARE MODE</span><br><span class="line"># 对修改的记录加一个X锁</span><br><span class="line">INSERT...</span><br><span class="line">UPDATE...</span><br><span class="line">DELETE...</span><br></pre></td></tr></table></figure>

<h1 id="4、索引"><a href="#4、索引" class="headerlink" title="4、索引"></a>4、索引</h1><p><strong>索引是一种用于快速查询和检索数据的数据结构。常见的索引结构有: B 树， B+树和 Hash</strong></p>
<h2 id="1、索引的底层数据结构"><a href="#1、索引的底层数据结构" class="headerlink" title="1、索引的底层数据结构"></a>1、索引的底层数据结构</h2><h3 id="1-Hash表"><a href="#1-Hash表" class="headerlink" title="1.Hash表"></a>1.Hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））</p>
<h3 id="2-为什么不使用Hash表作为索引的数据结构？"><a href="#2-为什么不使用Hash表作为索引的数据结构？" class="headerlink" title="2.为什么不使用Hash表作为索引的数据结构？*"></a>2.为什么不使用Hash表作为索引的数据结构？*</h3><p><strong>1.Hash 冲突问题</strong> ：我们上面也提到过Hash 冲突了，不过对于数据库来说这还不算最大的缺点。</p>
<p><strong>2.Hash 索引不支持顺序和范围查询(Hash 索引不支持顺序和范围查询是它最大的缺点）：</strong> 假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了</p>
<h3 id="3-B-树-amp-B-树"><a href="#3-B-树-amp-B-树" class="headerlink" title="3.B 树&amp; B+树"></a>3.B 树&amp; B+树</h3><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显</li>
</ul>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p>
<h3 id="4-MySQL为什么使用B-树"><a href="#4-MySQL为什么使用B-树" class="headerlink" title="4.MySQL为什么使用B+树"></a>4.MySQL为什么使用B+树</h3><ul>
<li>B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，<strong>B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I&#x2F;O次数会更少。</strong></li>
<li>B+ 树有<strong>大量的冗余节点</strong>（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在<strong>插入、删除的效率都更高</strong>，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</li>
<li>B+ 树叶子节点之间用链表连接了起来，<strong>有利于范围查询</strong>，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I&#x2F;O 操作，范围查询效率不如 B+ 树</li>
</ul>
<h3 id="5-InnoDB是如何存储数据的"><a href="#5-InnoDB是如何存储数据的" class="headerlink" title="5.InnoDB是如何存储数据的"></a>5.InnoDB是如何存储数据的</h3><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，<strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p>数据库的 I&#x2F;O 操作的最小单位是页，<strong>InnoDB 数据页的默认大小是 16KB</strong></p>
<p>数据页包括七个部分，结构如下图：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/243b1466779a9e107ae3ef0155604a17.png" style="zoom:67%;" />

<p>作用：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/fabd6dadd61a0aa342d7107213955a72.png" style="zoom:67%;" />

<p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表</p>
<hr>
<h4 id="User-Records"><a href="#User-Records" class="headerlink" title="User Records"></a>User Records</h4><p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p>
<p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。</p>
<p>那 InnoDB 是如何给记录创建页目录的呢？页目录与记录的关系如下图：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/261011d237bec993821aa198b97ae8ce.png" style="zoom: 50%;" />

<p>页目录创建的过程如下：</p>
<ol>
<li>将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；</li>
<li>每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）</li>
<li>页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），<strong>每个槽相当于指针指向了不同组的最后一个记录</strong></li>
</ol>
<p>从图可以看到，<strong>页目录就是由多个槽组成的，槽相当于分组记录的索引</strong>。然后，因为记录是按照「主键值」从小到大排序的，所以<strong>我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录</strong>，无需从最小记录开始遍历整个页中的记录链表</p>
<hr>
<p>看到第三步的时候，可能有的同学会疑问，如果某个槽内的记录很多，然后因为记录都是单向链表串起来的，那这样在槽内查找某个记录的时间复杂度不就是 O(n) 了吗？</p>
<p>这点不用担心，InnoDB 对每个分组中的记录条数都是有规定的，槽内的记录就只有几条：</p>
<ul>
<li>第一个分组中的记录只能有 1 条记录；</li>
<li>最后一个分组中的记录条数范围只能在 1-8 条之间；</li>
<li>剩下的分组中记录条数范围只能在 4-8 条之间。</li>
</ul>
<h3 id="6-B-树如何进行查询"><a href="#6-B-树如何进行查询" class="headerlink" title="6.B+树如何进行查询"></a>6.B+树如何进行查询</h3><p>因为一个数据页中的记录是有限的，且主键值是有序的，所以通过对所有记录进行分组，然后将组号（槽号）存储到页目录，使其起到索引作用，通过二分查找的方法快速检索到记录在哪个分组，来降低检索的时间复杂度。</p>
<p>但是，当我们需要存储大量的记录时，就需要多个数据页，这时我们就需要考虑如何建立合适的索引，才能方便定位记录所在的页。</p>
<p>为了解决这个问题，<strong>InnoDB 采用了 B+ 树作为索引</strong>。磁盘的 I&#x2F;O 操作次数对索引的使用效率至关重要，因此在构造索引的时候，我们更倾向于采用“矮胖”的 B+ 树数据结构，这样所需要进行的磁盘 I&#x2F;O 次数更少，而且 B+ 树 更适合进行关键字的范围查询。</p>
<p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p>
<img src="https://img-blog.csdnimg.cn/img_convert/7c635d682bd3cdc421bb9eea33a5a413.png" style="zoom:67%;" />

<p>通过上图，我们看出 B+ 树的特点：</p>
<ul>
<li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ul>
<blockquote>
<p>在InnoDB中，不管是存储目录的数据页其实还是存储真实数据的数据页是一个概念，<strong>它们拥有完全一致的页结构</strong>，不同之处在于 UserRecord存储的真实内容不同，在User Record中的记录有一个字段专门记录当前记录存储的是页面信息还是真实用户数据</p>
</blockquote>
<h2 id="2、索引类型"><a href="#2、索引类型" class="headerlink" title="2、索引类型"></a>2、索引类型</h2><h3 id="1-主键索引-Primary-Key"><a href="#1-主键索引-Primary-Key" class="headerlink" title="1.主键索引(Primary Key)"></a>1.主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键</p>
<h3 id="2-二级索引-辅助索引"><a href="#2-二级索引-辅助索引" class="headerlink" title="2.二级索引(辅助索引)"></a>2.二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引：</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符</li>
<li><strong>全文索引(Full Text)</strong> ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引</li>
</ol>
<h3 id="3-聚集索引"><a href="#3-聚集索引" class="headerlink" title="3.聚集索引"></a>3.聚集索引</h3><p><strong>聚集索引即索引结构和数据一起存放的索引。主键索引属于聚集索引。</strong></p>
<p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据</p>
<ul>
<li>优点：</li>
</ul>
<p>聚集索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据</p>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li><strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的</li>
</ol>
<h3 id="4-非聚集索引"><a href="#4-非聚集索引" class="headerlink" title="4.非聚集索引"></a>4.非聚集索引</h3><p><strong>二级索引属于非聚集索引。</strong></p>
<p>非聚集索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据</p>
<ul>
<li>优点：</li>
</ul>
<p><strong>更新代价比聚集索引要小</strong> 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的</p>
<ul>
<li>缺点：</li>
</ul>
<ol>
<li>跟聚集索引一样，非聚集索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong> :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20210420165311654.png"></p>
<h3 id="5-覆盖索引"><a href="#5-覆盖索引" class="headerlink" title="5.覆盖索引"></a>5.覆盖索引</h3><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p>
<p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<h3 id="6-自适应哈希索引"><a href="#6-自适应哈希索引" class="headerlink" title="6.自适应哈希索引"></a>6.自适应哈希索引</h3><p>InnoDB存储引擎会监控对表上各索引页的查询。<strong>如果观察到建立哈希索引可以带来速度提升，则建立哈希索引，称之为自适应哈希索引(Adaptive Hash Index, AHI)<strong>。AHI是通过缓冲池的B+树页构造而来，因此建立的速度很快，而且不需要对整张表构建哈希索引。InnoDB存储引擎会自动根据访问的频率和模式来自动地为某些热点页建立哈希索引<br>AHI有一个要求，</strong>对这个页的连续访问模式必须是一样的</strong>。例如对于(a,b)这样的联合索引页，其访问模式可以是下面情况：</p>
<ol>
<li>where a&#x3D;xxx</li>
<li>where a &#x3D;xxx and b&#x3D;xxx</li>
</ol>
<p>访问模式一样是指查询的条件是一样的，若交替进行上述两种查询，那么InnoDB存储引擎不会对该页构造AHI。<br>AHI还有下面几个要求：</p>
<ol>
<li>以该模式访问了100次</li>
<li>页通过该模式访问了N次，其中N&#x3D;页中记录*1&#x2F;16</li>
</ol>
<p>InnoDB存储引擎官方文档显示，启用AHI后，读取和写入速度可以提高2倍，辅助索引的连接操作性能可以提高5倍。AHI的设计思想是数据库自优化，不需要DBA对数据库进行手动调整</p>
<h3 id="7-联合索引"><a href="#7-联合索引" class="headerlink" title="7.联合索引"></a>7.联合索引</h3><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong></p>
<p><strong>联合索引的最左前缀匹配原则</strong></p>
<p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询，如 <strong><code>&gt;</code><strong>、</strong><code>&lt;</code><strong>、</strong><code>between</code></strong> 和 <strong><code>以%开头的like查询</code></strong> 等条件，才会停止匹配。</p>
<p>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</p>
<p>在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，<strong>联合索引会失效</strong>，这样就无法利用到索引快速查询的特性了。</p>
<hr>
<h4 id="联合索引范围查询"><a href="#联合索引范围查询" class="headerlink" title="联合索引范围查询"></a>联合索引范围查询</h4><p>联合索引有一些特殊情况，<strong>并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询</strong>，也就是可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p>
<p>这种特殊情况就发生在范围查询。联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。<strong>也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引</strong>。</p>
<p>总的来说，<strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配</strong></p>
<blockquote>
<p>建议看一下小林coding讲的，讲的很好：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB">https://xiaolincoding.com/mysql/index/index_interview.html#%E6%8C%89%E5%AD%97%E6%AE%B5%E4%B8%AA%E6%95%B0%E5%88%86%E7%B1%BB</a></p>
</blockquote>
<hr>
<h4 id="联合索引进行排序"><a href="#联合索引进行排序" class="headerlink" title="联合索引进行排序"></a>联合索引进行排序</h4><p>针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> status <span class="operator">=</span> <span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">asc</span></span><br></pre></td></tr></table></figure>

<p>有的同学会认为，单独给 status 建立一个索引就可以了。</p>
<p><strong>但是更好的方式给 status 和 create_time 列建立一个联合索引，因为这样可以避免 MySQL 数据库发生文件排序。</strong></p>
<p>因为在查询时，如果只用到 status 的索引，但是这条语句还要对 create_time 排序，这时就要用文件排序 filesort，也就是在 SQL 执行计划中，Extra 列会出现 Using filesort。</p>
<p>所以，要利用索引的有序性，在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率</p>
<h2 id="3、索引下推"><a href="#3、索引下推" class="headerlink" title="3、索引下推"></a>3、索引下推</h2><p>索引下推是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p>
<p>现在我们知道，对于联合索引（a, b），在执行 <code>select * from table where a &gt; 1 and b = 2</code> 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？</p>
<ul>
<li>在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。</li>
<li>而 MySQL 5.6 引入的<strong>索引下推优化</strong>（index condition pushdown)， <strong>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</strong>。</li>
</ul>
<p>当你的查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code>，那么说明使用了索引下推的优化</p>
<h2 id="4、索引优化"><a href="#4、索引优化" class="headerlink" title="4、索引优化"></a>4、索引优化</h2><p>这里说一下几种常见优化索引的方法：</p>
<ul>
<li>前缀索引优化；</li>
<li>覆盖索引优化；</li>
<li>主键索引最好是自增的；</li>
<li>防止索引失效；</li>
</ul>
<h3 id="1-前缀索引优化"><a href="#1-前缀索引优化" class="headerlink" title="1.前缀索引优化"></a>1.前缀索引优化</h3><p>前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？</p>
<p>使用前缀索引是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。</p>
<p>不过，前缀索引有一定的局限性，例如：</p>
<ul>
<li>order by 就无法使用前缀索引；</li>
<li>无法把前缀索引用作覆盖索引；</li>
</ul>
<h3 id="2-覆盖索引优化"><a href="#2-覆盖索引优化" class="headerlink" title="2.覆盖索引优化"></a>2.覆盖索引优化</h3><p>覆盖索引是指 SQL 中 query 的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作。</p>
<p>假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？</p>
<p>我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p>
<p>所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I&#x2F;O 操作</p>
<h3 id="3-主键索引最好是自增的"><a href="#3-主键索引最好是自增的" class="headerlink" title="3.主键索引最好是自增的"></a>3.主键索引最好是自增的</h3><p>我们在建表的时候，都会默认将主键索引设置为自增的，具体为什么要这样做呢？又什么好处？</p>
<p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+Tree 的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p>
<p><strong>如果我们使用自增主键</strong>，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次<strong>插入一条新记录，都是追加操作，不需要重新移动数据</strong>，因此这种插入数据的方法效率非常高。</p>
<p><strong>如果我们使用非自增主键</strong>，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为<strong>页分裂</strong>。<strong>页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率</strong>。</p>
<p>另外，主键字段的长度不要太大，因为<strong>主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小</strong></p>
<h3 id="4-索引最好设置为-NOT-NULL"><a href="#4-索引最好设置为-NOT-NULL" class="headerlink" title="4.索引最好设置为 NOT NULL"></a>4.索引最好设置为 NOT NULL</h3><p>为了更好的利用索引，索引列要设置为 NOT NULL 约束。有两个原因：</p>
<ul>
<li>第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。</li>
<li>第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，会导致更多的存储空间占用，因为 InnoDB 默认行存储格式<code>COMPACT</code>，会用 1 字节空间存储 NULL 值列表</li>
</ul>
<h3 id="5-防止索引失效"><a href="#5-防止索引失效" class="headerlink" title="5.防止索引失效"></a>5.防止索引失效</h3><p>发生索引失效的情况：</p>
<ul>
<li>当我们使用左或者左右模糊匹配的时候，也就是 <code>like %xx</code> 或者 <code>like %xx%</code>这两种方式都会造成索引失效；</li>
<li>当我们在查询条件中对索引列做了计算、函数、类型转换操作，这些情况下都会造成索引失效；</li>
<li>联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。</li>
<li>在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</li>
</ul>
<blockquote>
<p>具体了解：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w</a></p>
</blockquote>
<h2 id="5、索引失效"><a href="#5、索引失效" class="headerlink" title="5、索引失效"></a>5、索引失效</h2><p>具体看<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/index/index_lose.html%EF%BC%8C%E6%87%92%E5%BE%97%E5%86%99%E4%BA%86%EF%BC%8C%E6%9C%89%E7%A9%BA%E5%86%8D%E6%80%BB%E7%BB%93">https://xiaolincoding.com/mysql/index/index_lose.html，懒得写了，有空再总结</a></p>
<h3 id="1、对索引使用左或者左右模糊匹配"><a href="#1、对索引使用左或者左右模糊匹配" class="headerlink" title="1、对索引使用左或者左右模糊匹配"></a>1、对索引使用左或者左右模糊匹配</h3><h3 id="2、对索引使用函数"><a href="#2、对索引使用函数" class="headerlink" title="2、对索引使用函数"></a>2、对索引使用函数</h3><h3 id="3、对索引进行表达式计算"><a href="#3、对索引进行表达式计算" class="headerlink" title="3、对索引进行表达式计算"></a>3、对索引进行表达式计算</h3><h3 id="4、对索引隐式类型转换"><a href="#4、对索引隐式类型转换" class="headerlink" title="4、对索引隐式类型转换"></a>4、对索引隐式类型转换</h3><h3 id="5、联合索引非最左匹配"><a href="#5、联合索引非最左匹配" class="headerlink" title="5、联合索引非最左匹配"></a>5、联合索引非最左匹配</h3><h3 id="6、WHERE-子句中的-OR"><a href="#6、WHERE-子句中的-OR" class="headerlink" title="6、WHERE 子句中的 OR"></a>6、WHERE 子句中的 OR</h3><h1 id="5、日志（binlog，redo-log和undo-log）"><a href="#5、日志（binlog，redo-log和undo-log）" class="headerlink" title="5、日志（binlog，redo log和undo log）"></a>5、日志（binlog，redo log和undo log）</h1><p><code>MySQL</code> 日志 主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。其中，比较重要的还要属二进制日志 <code>binlog</code>（归档日志）和事务日志 <code>redo log</code>（重做日志）和 <code>undo log</code>（回滚日志）</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01.png" style="zoom:67%;" />

<h2 id="1、redo-log（重做日志）"><a href="#1、redo-log（重做日志）" class="headerlink" title="1、redo log（重做日志）"></a>1、redo log（重做日志）</h2><p><code>redo log</code>（重做日志）是<code>InnoDB</code>存储引擎独有的，它让<code>MySQL</code>拥有了崩溃恢复能力</p>
<p><code>MySQL</code> 中数据是以页为单位，你查询一条记录，会从硬盘把一页的数据加载出来，加载出来的数据叫数据页，会放入到 <code>Buffer Pool</code> 中。</p>
<p>后续的查询都是先从 <code>Buffer Pool</code> 中找，没有命中再去硬盘加载，减少硬盘 <code>IO</code> 开销，提升性能。</p>
<p>更新表数据的时候，也是如此，发现 <code>Buffer Pool</code> 里存在要更新的数据，就直接在 <code>Buffer Pool</code> 里更新。</p>
<p>然后会把“在某个数据页上做了什么修改”记录到重做日志缓存（<code>redo log buffer</code>）里，接着刷盘到 <code>redo log</code> 文件里</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03.png" style="zoom:67%;" />

<h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p><code>InnoDB</code> 存储引擎为 <code>redo log</code> 的刷盘策略提供了 <code>innodb_flush_log_at_trx_commit</code> 参数，它支持三种策略：</p>
<ul>
<li><strong>0</strong> ：设置为 0 的时候，表示每次事务提交时不进行刷盘操作</li>
<li><strong>1</strong> ：设置为 1 的时候，表示每次事务提交时都将进行刷盘操作（默认值）</li>
<li><strong>2</strong> ：设置为 2 的时候，表示每次事务提交时都只把 redo log buffer 内容写入 page cache</li>
</ul>
<p><code>innodb_flush_log_at_trx_commit</code> 参数默认为 1 ，也就是说当事务提交时会调用 <code>fsync</code> 对 redo log 进行刷盘</p>
<p>另外，<code>InnoDB</code> 存储引擎有一个后台线程，每隔<code>1</code> 秒，就会把 <code>redo log buffer</code> 中的内容写到文件系统缓存（<code>page cache</code>），然后调用 <code>fsync</code> 刷盘</p>
<p><strong>也就是说，一个没有提交事务的 <code>redo log</code> 记录，也可能会刷盘</strong></p>
<p><strong>除了后台线程每秒<code>1</code>次的轮询操作，还有一种情况，当 <code>redo log buffer</code> 占用的空间即将达到 <code>innodb_log_buffer_size</code> 一半的时候，后台线程会主动刷盘</strong></p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06.png" style="zoom:67%;" />

<ul>
<li><p>为<code>0</code>时，如果<code>MySQL</code>挂了或宕机可能会有<code>1</code>秒数据的丢失</p>
</li>
<li><p>为<code>1</code>时， 只要事务提交成功，<code>redo log</code>记录就一定在硬盘里，不会有任何数据丢失。</p>
<p>如果事务执行期间<code>MySQL</code>挂了或宕机，这部分日志丢了，但是事务并没有提交，所以日志丢了也不会有损失</p>
</li>
<li><p>为<code>2</code>时， 只要事务提交成功，<code>redo log buffer</code>中的内容只写入文件系统缓存（<code>page cache</code>）。</p>
<p>如果仅仅只是<code>MySQL</code>挂了不会有任何数据丢失，但是宕机可能会有<code>1</code>秒数据的丢失</p>
</li>
</ul>
<h3 id="日志文件组"><a href="#日志文件组" class="headerlink" title="日志文件组"></a>日志文件组</h3><p>硬盘上存储的 <code>redo log</code> 日志文件不只一个，而是以一个<strong>日志文件组</strong>的形式出现的，每个的<code>redo</code>日志文件大小都是一样的。</p>
<p>比如可以配置为一组<code>4</code>个文件，每个文件的大小是 <code>1GB</code>，整个 <code>redo log</code> 日志文件组可以记录<code>4G</code>的内容。</p>
<p>它采用的是环形数组形式，从头开始写，写到末尾又回到头循环写，如下图所示</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/10.png" style="zoom:67%;" />

<p>在个<strong>日志文件组</strong>中还有两个重要的属性，分别是 <code>write pos、checkpoint</code></p>
<ol>
<li><p><strong>write pos</strong> 是当前记录的位置，一边写一边后移</p>
</li>
<li><p><strong>checkpoint</strong> 是当前要擦除的位置，也是往后推移</p>
</li>
</ol>
<ul>
<li>每次刷盘 <code>redo log</code> 记录到<strong>日志文件组</strong>中，<code>write pos</code> 位置就会后移更新。</li>
</ul>
<p>每次 <code>MySQL</code> 加载<strong>日志文件组</strong>恢复数据时，会清空加载过的 <code>redo log</code> 记录，并把 <code>checkpoint</code> 后移更新。</p>
<ul>
<li><p><code>write pos</code> 和 <code>checkpoint</code> 之间的还空着的部分可以用来写入新的 <code>redo log</code> 记录</p>
</li>
<li><p>如果 <code>write pos</code> 追上 <code>checkpoint</code> ，表示<strong>日志文件组</strong>满了，这时候不能再写入新的 <code>redo log</code> 记录，<code>MySQL</code> 得停下来，清空一些记录，把 <code>checkpoint</code> 推进一下</p>
</li>
</ul>
<h3 id="为什么要用redo-log"><a href="#为什么要用redo-log" class="headerlink" title="为什么要用redo log"></a>为什么要用redo log</h3><p>现在我们来思考一个问题： <strong>只要每次把修改后的数据页直接刷盘不就好了，还有 <code>redo log</code> 什么事？</strong></p>
<p>它们不都是刷盘么？差别在哪里？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Byte = 8bit</span><br><span class="line"><span class="number">1</span> KB = <span class="number">1024</span> Byte</span><br><span class="line"><span class="number">1</span> MB = <span class="number">1024</span> KB</span><br><span class="line"><span class="number">1</span> GB = <span class="number">1024</span> MB</span><br><span class="line"><span class="number">1</span> TB = <span class="number">1024</span> GB</span><br></pre></td></tr></table></figure>

<p>实际上，数据页大小是<code>16KB</code>，刷盘比较耗时，可能就修改了数据页里的几 <code>Byte</code> 数据，有必要把完整的数据页刷盘吗？</p>
<p>而且数据页刷盘是随机写，因为一个数据页对应的位置可能在硬盘文件的随机位置，所以性能是很差。</p>
<p>如果是写 <code>redo log</code>，一行记录可能就占几十 <code>Byte</code>，只包含表空间号、数据页号、磁盘文件偏移量、更新值，再加上是顺序写，所以刷盘速度很快。</p>
<p>所以用 <code>redo log</code> 形式记录修改内容，性能会远远超过刷数据页的方式，这也让数据库的并发能力更强</p>
<h2 id="2、binlog（归档日志）"><a href="#2、binlog（归档日志）" class="headerlink" title="2、binlog（归档日志）"></a>2、binlog（归档日志）</h2><p><code>redo log</code> 它是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 <code>InnoDB</code> 存储引擎。</p>
<p>而 <code>binlog</code> 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p>不管用什么存储引擎，只要发生了表数据更新，都会产生 <code>binlog</code> 日志</p>
<p>binlog的作用：<strong>主从同步</strong></p>
<p>可以说<code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01-20220305234724956.png" style="zoom:67%;" />

<p><code>binlog</code>会记录所有涉及更新数据的逻辑操作，并且是顺序写</p>
<h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p><code>binlog</code> 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ul>
<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/02-20220305234738688.png"></p>
<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/03-20220305234742460.png" style="zoom:67%;" />

<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>
<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>
<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗<code>IO</code>资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
<p><code>MySQL</code>会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式</p>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p><code>binlog</code>的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到<code>binlog</code>文件中。</p>
<p>因为一个事务的<code>binlog</code>不能被拆开，无论这个事务多大，也要确保一次性写入，所以系统会给每个线程分配一个块内存作为<code>binlog cache</code></p>
<p>我们可以通过<code>binlog_cache_size</code>参数控制单个线程 binlog cache 大小，如果存储内容超过了这个参数，就要暂存到磁盘（<code>Swap</code>）</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234747840.png" style="zoom: 50%;" />

<ul>
<li><strong>上图的 write，是指把日志写入到文件系统的 page cache，并没有把数据持久化到磁盘，所以速度比较快</strong></li>
<li><strong>上图的 fsync，才是将数据持久化到磁盘的操作</strong></li>
</ul>
<p><code>write</code>和<code>fsync</code>的时机，可以由参数<code>sync_binlog</code>控制，默认是<code>0</code>。</p>
<ul>
<li><p>为<code>0</code>的时候，表示每次提交事务都只<code>write</code>，由系统自行判断什么时候执行<code>fsync</code></p>
</li>
<li><p>虽然性能得到提升，但是机器宕机，<code>page cache</code>里面的 binlog 会丢失。</p>
<p>为了安全起见，可以设置为<code>1</code>，表示每次提交事务都会执行<code>fsync</code>，就如同 <strong>redo log 日志刷盘流程</strong> 一样</p>
</li>
<li><p>最后还有一种折中方式，可以设置为<code>N(N&gt;1)</code>，表示每次提交事务都<code>write</code>，但累积<code>N</code>个事务后才<code>fsync</code></p>
</li>
</ul>
<h2 id="3、两阶段提交"><a href="#3、两阶段提交" class="headerlink" title="3、两阶段提交"></a>3、两阶段提交</h2><p><strong><code>redo log</code>（重做日志）让<code>InnoDB</code>存储引擎拥有了崩溃恢复能力。</strong></p>
<p><strong><code>binlog</code>（归档日志）保证了<code>MySQL</code>集群架构的数据一致性</strong></p>
<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>在执行更新语句过程，会记录<code>redo log</code>与<code>binlog</code>两块日志，以基本的事务为单位，<code>redo log</code>在事务执行过程中可以不断写入，而<code>binlog</code>只有在提交事务时才写入（刷盘），所以<code>redo log</code>与<code>binlog</code>的写入时机不一样</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/01-20220305234816065.png" style="zoom:67%;" />

<p>如果binlog在写入时出了问题，而redo log无问题，则在MySQL恢复数据时主的值为redo中的操作值，而其他如SQL从的值则会跟随binlog恢复而无改变造成数据不一致的问题</p>
<p>为了解决两份日志之间的逻辑一致问题，<code>InnoDB</code>存储引擎使用<strong>两阶段提交</strong>方案</p>
<p>原理很简单，将<code>redo log</code>的写入拆成了两个步骤<code>prepare</code>和<code>commit</code>，这就是<strong>两阶段提交</strong></p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/04-20220305234956774.png" style="zoom:67%;" />

<p>使用<strong>两阶段提交</strong>后，写入<code>binlog</code>时发生异常也不会有影响，因为<code>MySQL</code>根据<code>redo log</code>日志恢复数据时，发现<code>redo log</code>还处于<code>prepare</code>阶段，并且没有对应<code>binlog</code>日志，就会回滚该事务</p>
<p>如果<code>redo log</code>设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>
<img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/06-20220305234907651.png" style="zoom:67%;" />

<p>并不会回滚事务，它会执行上图框住的逻辑，虽然<code>redo log</code>是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的<code>binlog</code>日志，所以<code>MySQL</code>认为是完整的，就会提交事务恢复数据</p>
<h2 id="4、undo-log"><a href="#4、undo-log" class="headerlink" title="4、undo log"></a>4、undo log</h2><p>我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行<strong>回滚</strong>，在 MySQL 中，恢复机制是通过 <strong>回滚日志（undo log）</strong> 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 <strong>回滚日志</strong> 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。</p>
<p>另外，<code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>MySQL InnoDB 引擎使用 <strong>redo log(重做日志)</strong> 保证事务的<strong>持久性</strong>，使用 <strong>undo log(回滚日志)</strong> 来保证事务的<strong>原子性</strong>。</p>
<p><code>MySQL</code>数据库的<strong>数据备份、主备、主主、主从</strong>都离不开<code>binlog</code>，需要依靠<code>binlog</code>来同步数据，保证数据一致性</p>
<h1 id="6、MVCC多版本并发控制"><a href="#6、MVCC多版本并发控制" class="headerlink" title="6、MVCC多版本并发控制"></a>6、MVCC多版本并发控制</h1><h2 id="1、一致性非锁定读"><a href="#1、一致性非锁定读" class="headerlink" title="1、一致性非锁定读"></a>1、一致性非锁定读</h2><p>对于 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html"><strong>一致性非锁定读（Consistent Nonlocking Reads）</strong> </a>的实现，通常做法是加一个版本号或者时间戳字段，在更新数据的同时版本号 + 1 或者更新时间戳。查询时，将当前可见的版本号与对应记录的版本号进行比对，如果记录的版本小于可见版本，则表示该记录可见</p>
<p>在 <code>InnoDB</code> 存储引擎中，<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">多版本控制 (multi versioning)</a> 就是对非锁定读的实现。如果读取的行正在执行 <code>DELETE</code> 或 <code>UPDATE</code> 操作，这时读取操作不会去等待行上锁的释放。相反地，<code>InnoDB</code> 存储引擎会去读取行的一个快照数据，对于这种读取历史数据的方式，我们叫它快照读 (snapshot read)</p>
<p>在 <code>Repeatable Read</code> 和 <code>Read Committed</code> 两个隔离级别下，如果是执行普通的 <code>select</code> 语句（不包括 <code>select ... lock in share mode</code> ,<code>select ... for update</code>）则会使用 <code>一致性非锁定读</code>。并且在 <code>Repeatable Read</code> 下 <code>MVCC</code> 实现了可重复读和防止部分幻读</p>
<h2 id="2、锁定读"><a href="#2、锁定读" class="headerlink" title="2、锁定读"></a>2、锁定读</h2><p>如果执行的是下列语句，就是 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html">锁定读（Locking Reads）</a></p>
<ul>
<li><code>select ... lock in share mode</code></li>
<li><code>select ... for update</code></li>
<li><code>insert</code>、<code>update</code>、<code>delete</code> 操作</li>
</ul>
<p>在锁定读下，读取的是数据的最新版本，这种读也被称为 <code>当前读（current read）</code>。锁定读会对读取到的记录加锁：</p>
<ul>
<li><code>select ... lock in share mode</code>：对记录加 <code>S</code> 锁，其它事务也可以加<code>S</code>锁，如果加 <code>x</code> 锁则会被阻塞</li>
<li><code>select ... for update</code>、<code>insert</code>、<code>update</code>、<code>delete</code>：对记录加 <code>X</code> 锁，且其它事务不能加任何锁</li>
</ul>
<p>在一致性非锁定读下，即使读取的记录已被其它事务加上 <code>X</code> 锁，这时记录也是可以被读取的，即读取的快照数据。上面说了，在 <code>Repeatable Read</code> 下 <code>MVCC</code> 防止了部分幻读，这边的 “部分” 是指在 <code>一致性非锁定读</code> 情况下，只能读取到第一次查询之前所插入的数据（根据 Read View 判断数据可见性，Read View 在第一次查询时生成）。但是！如果是 <code>当前读</code> ，每次读取的都是最新数据，这时如果两次查询中间有其它事务插入数据，就会产生幻读。所以， <strong><code>InnoDB</code> 在实现<code>Repeatable Read</code> 时，如果执行的是当前读，则会对读取的记录使用 <code>Next-key Lock</code> ，来防止其它事务在间隙间插入数据</strong></p>
<h2 id="3、InnoDB对MVCC的实现"><a href="#3、InnoDB对MVCC的实现" class="headerlink" title="3、InnoDB对MVCC的实现"></a>3、InnoDB对MVCC的实现</h2><p><code>MVCC</code> 的实现依赖于：<strong>隐藏字段、Read View、undo log</strong>。在内部实现中，<code>InnoDB</code> 通过数据行的 <code>DB_TRX_ID</code> 和 <code>Read View</code> 来判断数据的可见性，如不可见，则通过数据行的 <code>DB_ROLL_PTR</code> 找到 <code>undo log</code> 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 <code>Read View</code> 之前已经提交的修改和该事务本身做的修改</p>
<h3 id="1-隐藏字段"><a href="#1-隐藏字段" class="headerlink" title="1.隐藏字段"></a>1.隐藏字段</h3><p>在内部，<code>InnoDB</code> 存储引擎为每行数据添加了三个<strong>隐藏字段：</strong></p>
<ul>
<li><code>DB_TRX_ID（6字节）</code>：表示最后一次插入或更新该行的事务 id。此外，<code>delete</code> 操作在内部被视为更新，只不过会在记录头 <code>Record header</code> 中的 <code>deleted_flag</code> 字段将其标记为已删除</li>
<li><code>DB_ROLL_PTR（7字节）</code> 回滚指针，指向该行的 <code>undo log</code> 。如果该行未被更新，则为空</li>
<li><code>DB_ROW_ID（6字节）</code>：如果没有设置主键且该表没有唯一非空索引时，<code>InnoDB</code> 会使用该 id 来生成聚簇索引</li>
</ul>
<h3 id="2-ReadView"><a href="#2-ReadView" class="headerlink" title="2.ReadView"></a>2.ReadView</h3><p><a target="_blank" rel="noopener" href="https://github.com/facebook/mysql-8.0/blob/8.0/storage/innobase/include/read0types.h#L298"><code>Read View</code></a> 主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p>
<p>主要有以下字段：</p>
<ul>
<li><code>m_low_limit_id</code>：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li>
<li><code>m_up_limit_id</code>：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code>。小于这个 ID 的数据版本均可见</li>
<li><code>m_ids</code>：<code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code>时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。<code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li>
<li><code>m_creator_trx_id</code>：创建该 <code>Read View</code> 的事务 ID</li>
</ul>
<p><img src="https://javaguide.cn/assets/trans_visible.048192c5.png"></p>
<h3 id="3-undo-log"><a href="#3-undo-log" class="headerlink" title="3.undo-log"></a>3.undo-log</h3><p><code>undo log</code> 主要有两个作用：</p>
<ul>
<li>当事务回滚时用于将数据恢复到修改前的样子</li>
<li>另一个作用是 <code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li>
</ul>
<p><strong>在 <code>InnoDB</code> 存储引擎中 <code>undo log</code> 分为两种： <code>insert undo log</code> 和 <code>update undo log</code>：</strong></p>
<ol>
<li><strong><code>insert undo log</code></strong> ：指在 <code>insert</code> 操作中产生的 <code>undo log</code>。因为 <code>insert</code> 操作的记录只对事务本身可见，对其他事务不可见，故该 <code>undo log</code> 可以在事务提交后直接删除。不需要进行 <code>purge</code> 操作</li>
<li><strong><code>update undo log</code></strong> ：<code>update</code> 或 <code>delete</code> 操作中产生的 <code>undo log</code>。该 <code>undo log</code>可能需要提供 <code>MVCC</code> 机制，因此不能在事务提交时就进行删除。提交时放入 <code>undo log</code> 链表，等待 <code>purge线程</code> 进行最后的删除</li>
</ol>
<p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 <code>undo log</code> 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录</p>
<h2 id="4、数据可见性算法"><a href="#4、数据可见性算法" class="headerlink" title="4、数据可见性算法"></a>4、数据可见性算法</h2><p>在 <code>InnoDB</code> 存储引擎中，创建一个新事务后，执行每个 <code>select</code> 语句前，都会创建一个快照（Read View），<strong>快照中保存了当前数据库系统中正处于活跃（没有 commit）的事务的 ID 号</strong>。其实简单的说保存的是系统中当前不应该被本事务看到的其他事务 ID 列表（即 m_ids）。当用户在这个事务中要读取某个记录行的时候，<code>InnoDB</code> 会将该记录行的 <code>DB_TRX_ID</code> 与 <code>Read View</code> 中的一些变量及当前事务 ID 进行比较，判断是否满足可见性条件</p>
<p><img src="https://javaguide.cn/assets/8778836b-34a8-480b-b8c7-654fe207a8c2.3d84010e.png"></p>
<ol>
<li>如果记录 DB_TRX_ID &lt; m_up_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之前就提交了，所以该记录行的值对当前事务是可见的</li>
<li>如果 DB_TRX_ID &gt;&#x3D; m_low_limit_id，那么表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照之后才修改该行，所以该记录行的值对当前事务不可见。跳到步骤 5</li>
<li>m_ids 为空，则表明在当前事务创建快照之前，修改该行的事务就已经提交了，所以该记录行的值对当前事务是可见的</li>
<li>如果 m_up_limit_id &lt;&#x3D; DB_TRX_ID &lt; m_low_limit_id，表明最新修改该行的事务（DB_TRX_ID）在当前事务创建快照的时候可能处于“活动状态”或者“已提交状态”；所以就要对活跃事务列表 m_ids 进行查找（源码中是用的二分查找，因为是有序的）<ul>
<li>如果在活跃事务列表 m_ids 中能找到 DB_TRX_ID，表明：① 在当前事务创建快照前，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了，但没有提交；或者 ② 在当前事务创建快照后，该记录行的值被事务 ID 为 DB_TRX_ID 的事务修改了。这些情况下，这个记录行的值对当前事务都是不可见的。跳到步骤 5</li>
<li>在活跃事务列表中找不到，则表明“id 为 trx_id 的事务”在修改“该记录行的值”后，在“当前事务”创建快照前就已经提交了，所以记录行对当前事务可见</li>
</ul>
</li>
<li>在该记录行的 DB_ROLL_PTR 指针所指向的 <code>undo log</code> 取出快照记录，用快照记录的 DB_TRX_ID 跳到步骤 1 重新开始判断，直到找到满足的快照版本或返回空</li>
</ol>
<h2 id="5、RC-和-RR-隔离级别下-MVCC-的差异"><a href="#5、RC-和-RR-隔离级别下-MVCC-的差异" class="headerlink" title="5、RC 和 RR 隔离级别下 MVCC 的差异"></a>5、RC 和 RR 隔离级别下 MVCC 的差异</h2><p>在事务隔离级别 <code>RC</code> 和 <code>RR</code> （InnoDB 存储引擎的默认事务隔离级别）下，<code>InnoDB</code> 存储引擎使用 <code>MVCC</code>（非锁定一致性读），但它们生成 <code>Read View</code> 的时机却不同</p>
<ul>
<li>在 RC 隔离级别下的 <strong><code>每次select</code></strong> 查询前都生成一个<code>Read View</code> (m_ids 列表)</li>
<li>在 RR 隔离级别下只在事务开始后 <strong><code>第一次select</code></strong> 数据前生成一个<code>Read View</code>（m_ids 列表）</li>
</ul>
<h2 id="6、MVCC-解决不可重复读问题"><a href="#6、MVCC-解决不可重复读问题" class="headerlink" title="6、MVCC 解决不可重复读问题"></a>6、MVCC 解决不可重复读问题</h2><p>虽然 RC 和 RR 都通过 <code>MVCC</code> 来读取快照数据，但由于 <strong>生成 Read View 时机不同</strong>，从而在 RR 级别下实现可重复读</p>
<blockquote>
<p><strong>在 RC 隔离级别下，事务在每次查询开始时都会生成并设置新的 Read View，所以导致不可重复读</strong></p>
<p>具体是为什么呢？我的理解是，因为RC隔离级别下，每次select之前都会设置新的Read View，所以对于同一个事务（也就是id一样）来说，在不同的select语句查询之后所处的位置不同，从而可能导致不可重复读，比如都是id为103的事务，在第一次select之前创建的Read View中可能处于当前出现过的最大id（m_low_limit_id）102和最小id（m_up_limit_id）101之间从而不可见，但第二次select后101提交了从而最小id变为102导致读取的Read View（在undo log中查找）就是101修改的从而产生不可重复读</p>
<p>也就是说对于一个事务A对一个记录进行访问时，不同时期的另一事务B对此事务A的可见性不相同，第一次查询时事务B是不可见的，但在第一次查询到第二次查询的过程中事务B已提交因而事务B对事务A变为可见（Read View新建），这就导致读取的数据改变从而造成不可重复读</p>
</blockquote>
<h2 id="7、MVCC➕Next-key-Lock-防止部分幻读"><a href="#7、MVCC➕Next-key-Lock-防止部分幻读" class="headerlink" title="7、MVCC➕Next-key-Lock 防止部分幻读"></a>7、MVCC➕Next-key-Lock 防止部分幻读</h2><p><code>InnoDB</code>存储引擎在 RR 级别下通过 <code>MVCC</code>和 <code>Next-key Lock</code> 来解决幻读问题：</p>
<p><strong>1、执行普通 <code>select</code>，此时会以 <code>MVCC</code> 快照读的方式读取数据</strong></p>
<p>在快照读的情况下，RR 隔离级别只会在事务开启后的第一次查询生成 <code>Read View</code> ，并使用至事务提交。所以在生成 <code>Read View</code> 之后其它事务所做的更新、插入记录版本对当前事务并不可见，实现了可重复读和防止快照读下的 “幻读”</p>
<p><strong>2、执行 select…for update&#x2F;lock in share mode、insert、update、delete 等当前读</strong></p>
<p>在当前读下，读取的都是最新的数据，如果其它事务有插入新的记录，并且刚好在当前事务查询范围内，就会产生幻读！<code>InnoDB</code> 使用 <a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-next-key-locks">Next-key Lock</a> 来防止这种情况。当执行当前读时，会锁定读取到的记录的同时，锁定它们的间隙，防止其它事务在查询范围内插入数据。只要我不让你插入，就不会发生幻读</p>
<blockquote>
<p>注意：MVCC并不能完全防止幻读，具体见：<a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97">RR级别下的幻读</a></p>
</blockquote>
<h1 id="7、MySQL内存"><a href="#7、MySQL内存" class="headerlink" title="7、MySQL内存"></a>7、MySQL内存</h1><h2 id="7-1、MySQL一行记录是怎么存储的？"><a href="#7-1、MySQL一行记录是怎么存储的？" class="headerlink" title="7.1、MySQL一行记录是怎么存储的？"></a>7.1、MySQL一行记录是怎么存储的？</h2><p>MySQL默认使用InnoDB存储引擎，所以主要讲InnoDB存储引擎的存储方式</p>
<h3 id="1-MySQL数据存放在什么文件中"><a href="#1-MySQL数据存放在什么文件中" class="headerlink" title="1.MySQL数据存放在什么文件中"></a>1.MySQL数据存放在什么文件中</h3><p>我们每创建一个 database（数据库） 都会在 &#x2F;var&#x2F;lib&#x2F;mysql&#x2F; 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。</p>
<p>在数据库文件中共有三个文件，这三个文件分别代表着：</p>
<ul>
<li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li>
<li>t_order.frm ，t_order 的<strong>表结构</strong>会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。</li>
<li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.idb）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .idb 文件</li>
</ul>
<p>好了，现在我们知道了一张数据库表的数据是保存在「 表名字.idb 」的文件里的，这个文件也称为独占表空间文件</p>
<h3 id="2-表空间文件的结构"><a href="#2-表空间文件的结构" class="headerlink" title="2.表空间文件的结构"></a>2.表空间文件的结构</h3><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB存储引擎的逻辑存储结构大致如下图：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png" style="zoom:67%;" />

<h4 id="1、行（row）"><a href="#1、行（row）" class="headerlink" title="1、行（row）"></a>1、行（row）</h4><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p>
<p>后面我们详细介绍 InnoDB 存储引擎的行格式，也是本文重点介绍的内容</p>
<h4 id="2、页（page）"><a href="#2、页（page）" class="headerlink" title="2、页（page）"></a>2、页（page）</h4><p>记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</p>
<p>因此，<strong>InnoDB 的数据是按「页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。<strong>默认每个页的大小为 16KB</strong>，也就是最多能保证 16KB 的连续存储空间</p>
<p>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。<strong>数据表中的行记录是用「数据页」来管理的</strong></p>
<h4 id="3、区（extent）"><a href="#3、区（extent）" class="headerlink" title="3、区（extent）"></a>3、区（extent）</h4><p>我们知道 InnoDB 存储引擎是用 B+ 树来组织数据的。</p>
<p>B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I&#x2F;O，随机 I&#x2F;O 是非常慢的。</p>
<p>解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I&#x2F;O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。</p>
<p>那具体怎么解决呢？</p>
<p><strong>在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I&#x2F;O 了</strong>。</p>
<h4 id="4、段（segment）"><a href="#4、段（segment）" class="headerlink" title="4、段（segment）"></a>4、段（segment）</h4><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p>
<ul>
<li>索引段：存放 B + 树的非叶子节点的区的集合；</li>
<li>数据段：存放 B + 树的叶子节点的区的集合；</li>
<li>回滚段：存放的是回滚数据的区的集合，之前讲<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/transaction/mvcc.html">事务隔离</a>的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。</li>
</ul>
<h3 id="3-InnoDB-行格式有哪些？"><a href="#3-InnoDB-行格式有哪些？" class="headerlink" title="3.InnoDB 行格式有哪些？"></a>3.InnoDB 行格式有哪些？</h3><p>行格式（row_format），就是一条记录的存储结构。</p>
<p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。</p>
<ul>
<li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li>
<li>由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</li>
<li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式</li>
</ul>
<h3 id="4-Compact行格式"><a href="#4-Compact行格式" class="headerlink" title="4.Compact行格式"></a>4.Compact行格式</h3><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" style="zoom:67%;" />

<p>可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。</p>
<h4 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h4><p>记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息</p>
<h5 id="1-变长字段长度列表"><a href="#1-变长字段长度列表" class="headerlink" title="1. 变长字段长度列表"></a>1. 变长字段长度列表</h5><p>varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。</p>
<p>所以，在存储数据的时候要把这些数据占用的字节数也存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据。其他 TEXT、BLOB 等变长字段也是这么实现的。</p>
<p>注意：</p>
<ul>
<li>这些变长字段的长度值会按照列的顺序<strong>逆序存放</strong></li>
<li><strong>NULL 是不会存放在行格式中记录的真实数据部分里的</strong>，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度</li>
</ul>
<hr>
<blockquote>
<p><strong>为什么「变长字段长度列表」的信息要按照逆序存放？</strong></p>
</blockquote>
<p>这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真是数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</p>
<p>「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以<strong>使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率</strong>。</p>
<p>同样的道理， NULL 值列表的信息也需要逆序存放</p>
<hr>
<blockquote>
<p><strong>每个数据库表的行格式都有「变长字段字节数列表」吗？</strong></p>
</blockquote>
<p>其实变长字段字节数列表不是必须的。</p>
<p><strong>当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了</strong>，因为没必要，不如去掉以节省空间。</p>
<p>所以「变长字段长度列表」只出现在数据表有变长字段的时候</p>
<h5 id="2-NULL-值列表"><a href="#2-NULL-值列表" class="headerlink" title="2. NULL 值列表"></a>2. NULL 值列表</h5><p>表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中</p>
<p>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。</p>
<ul>
<li>二进制位的值为<code>1</code>时，代表该列的值为NULL。</li>
<li>二进制位的值为<code>0</code>时，代表该列的值不为NULL。</li>
</ul>
<p>另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 <code>0</code></p>
<hr>
<blockquote>
<p>每个数据库表的行格式都有「NULL 值列表」吗？</p>
</blockquote>
<p>NULL 值列表也不是必须的。</p>
<p><strong>当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了</strong>。所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以节省 1 字节的空间（NULL 值列表占用 1 字节空间）</p>
<h5 id="3-记录头信息"><a href="#3-记录头信息" class="headerlink" title="3. 记录头信息"></a>3. 记录头信息</h5><p>记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：</p>
<ul>
<li>delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1</li>
<li>next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真是数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。</li>
<li>record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</li>
</ul>
<h4 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h4><p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer，这三个字段是用于mvcc的，后面有详细的说明就不在这说了</p>
<h3 id="5-varchar-n-中-n-最大取值为多少？"><a href="#5-varchar-n-中-n-最大取值为多少？" class="headerlink" title="5.varchar(n) 中 n 最大取值为多少？"></a>5.varchar(n) 中 n 最大取值为多少？</h3><p>varchar(n) 字段类型的 n 代表的是最多存储的字符数量，那 n 最大能设置多少？</p>
<p>这个问题要考虑两个因素：</p>
<ul>
<li>行格式中「变长字段长度列表」最大能表示多少字节？知道了这个才能知道，一行数据最大能存储多少字节的数据。</li>
<li>数据库表的字符集，确定了这个，才能知道 1 个字符占用多少字节。</li>
</ul>
<p>行格式中「变长字段长度列表」有时候是占用 1 字节，有时候是占用 2 字节：</p>
<ul>
<li>如果变成字段允许存储的最大字节数小于等于 255 字节，「变长字段长度列表」就占用 1 个字节；</li>
<li>如果变成字段允许存储的最大字节数大于 255 字节，「变长字段长度列表」就占用 2 个字节；</li>
</ul>
<p>可以看到，<strong>「变长字段长度列表」占用的字节数最大不会不超过 2 字节</strong>，2 个字节的最大值是 65535（十进制），<strong>但一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数，所以最多可以存储 65535- 2 - 1 &#x3D; 65532 字节，如果不能为null则为65535-2 &#x3D; 65533字节</strong></p>
<blockquote>
<p>具体探索过程看：<a target="_blank" rel="noopener" href="https://xiaolincoding.com/mysql/base/row_format.html#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE">varchar(n) 中 n 最大取值为多少？</a>，讲的很好</p>
</blockquote>
<h3 id="6-行溢出后，MySQL-怎么处理"><a href="#6-行溢出后，MySQL-怎么处理" class="headerlink" title="6.行溢出后，MySQL 怎么处理"></a>6.行溢出后，MySQL 怎么处理</h3><p>MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 <code>16KB</code>，也就是 <code>16384字节</code>，而一个 varchar(n) 类型的列最多可以存储 <code>65532字节</code>，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p>
<p>如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。</p>
<p><strong>当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中</strong>，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA.png" style="zoom:67%;" />

<p>上面这个是 Compact 行格式在发生行溢出后的处理。</p>
<p>Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。</p>
<p>这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中，看起来就像下面这样：</p>
<p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png"></p>
<h2 id="7-2、BufferPool"><a href="#7-2、BufferPool" class="headerlink" title="7.2、BufferPool"></a>7.2、BufferPool</h2><p>为了提升性能，MySQL使用了缓存技术，当数据从磁盘中取出后，缓存内存中，下次查询同样的数据的时候，直接从内存中读取。</p>
<p>为此，Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，<strong>buffer pool会缓存热的数据页和索引页，减少磁盘读操作</strong>，来提高数据库的读性能</p>
<p>有了缓冲池后：</p>
<ul>
<li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li>
<li>当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘</li>
</ul>
<blockquote>
<p>Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 <code>128MB</code></p>
</blockquote>
<h3 id="1、Buffer-Pool缓存"><a href="#1、Buffer-Pool缓存" class="headerlink" title="1、Buffer Pool缓存"></a>1、Buffer Pool缓存</h3><p>因为InnoDB以页为磁盘和内存交互的基本单位，因此Buffer Pool也需要按页划分</p>
<p>在 MySQL 启动的时候，<strong>InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的<code>16KB</code>的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页</strong>。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中</p>
<p>Buffer Pool 除了缓存「索引页」和「数据页」，还包括了 undo 页，插入缓存、自适应哈希索引、锁信息等等。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png" style="zoom:50%;" />

<p>为了更好的管理这些在 Buffer Pool 中的缓存页，InnoDB 为每一个缓存页都创建了一个<strong>控制块</strong>，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等</p>
<p>控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png" style="zoom:67%;" />

<p>上图中控制块和缓存页之间灰色部分称为碎片空间</p>
<h3 id="2、Buffer-Pool的管理"><a href="#2、Buffer-Pool的管理" class="headerlink" title="2、Buffer Pool的管理"></a>2、Buffer Pool的管理</h3><h4 id="1-空闲页的管理"><a href="#1-空闲页的管理" class="headerlink" title="1.空闲页的管理"></a>1.空闲页的管理</h4><p>Buffer Pool 是一片连续的内存空间，当 MySQL 运行一段时间后，这片连续的内存空间中的缓存页既有空闲的，也有被使用的。</p>
<p>为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 <strong>Free 链表</strong>（空闲链表）</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/freelist.drawio.png" style="zoom: 50%;" />

<p>Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 Free 链表节点都对应一个空闲的缓存页。</p>
<p>有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除</p>
<h4 id="2-脏页的管理"><a href="#2-脏页的管理" class="headerlink" title="2.脏页的管理"></a>2.脏页的管理</h4><p>设计 Buffer Pool 除了能提高读性能，还能提高写性能，也就是更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为<strong>脏页</strong>，然后再由后台线程将脏页写入到磁盘。</p>
<p>那为了能快速知道哪些缓存页是脏的，于是就设计出 <strong>Flush 链表</strong>，它跟 Free 链表类似的，链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/Flush.drawio.png" style="zoom:50%;" />

<h4 id="3-如何提高缓存命中率"><a href="#3-如何提高缓存命中率" class="headerlink" title="3.如何提高缓存命中率"></a>3.如何提高缓存命中率</h4><p>Buffer Pool使用LRU算法来提升缓存命中率</p>
<p>Buffer Pool 里有三种页和链表来管理数据：</p>
<ul>
<li>Free Page（空闲页），表示此页未被使用，位于 Free 链表；</li>
<li>Clean Page（干净页），表示此页已被使用，但是页面未发生修改，位于LRU 链表。</li>
<li>Dirty Page（脏页），表示此页「已被使用」且「已经被修改」，其数据和磁盘上的数据已经不一致。当脏页上的数据写入磁盘后，内存数据和磁盘数据一致，那么该页就变成了干净页。脏页同时存在于 LRU 链表和 Flush 链表</li>
<li><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpoll_page.png" style="zoom:50%;" /></li>
</ul>
<p>简单的 LRU 算法并没有被 MySQL 使用，因为简单的 LRU 算法无法避免下面这两个问题：</p>
<ul>
<li>预读失效；</li>
<li>Buffer Pool 污染；</li>
</ul>
<hr>
<h5 id="预读失效"><a href="#预读失效" class="headerlink" title="预读失效"></a>预读失效</h5><blockquote>
<p>什么是预读失效？</p>
</blockquote>
<p>先来说说 MySQL 的预读机制。程序是有空间局部性的，靠近当前被访问数据的数据，在未来很大概率会被访问到。</p>
<p>所以，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。</p>
<p>但是可能这些<strong>被提前加载进来的数据页，并没有被访问</strong>，相当于这个预读是白做了，这个就是<strong>预读失效</strong>。</p>
<p>如果使用简单的 LRU 算法，就会把预读页放到 LRU 链表头部，而当 Buffer Pool空间不够的时候，还需要把末尾的页淘汰掉。</p>
<p>如果这些预读页如果一直不会被访问到，就会出现一个很奇怪的问题，不会被访问的预读页却占用了 LRU 链表前排的位置，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率</p>
<blockquote>
<p>如何解决预读失效而导致缓存命中率降低的问题？</p>
</blockquote>
<p>要避免预读失效带来影响，最好就是<strong>让预读的页停留在 Buffer Pool 里的时间要尽可能的短，让真正被访问的页才移动到 LRU 链表的头部，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长</strong>。</p>
<p>MySQL 改进了 LRU 算法，将 LRU 划分了 2 个区域：<strong>old 区域 和 young 区域</strong>。</p>
<p>young 区域在 LRU 链表的前半部分，old 区域则是在后半部分</p>
<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/young%2Bold.png" style="zoom:50%;" />

<p><strong>划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部</strong>。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。</p>
<p>虽然通过划分 old 区域 和 young 区域避免了预读失效带来的影响，但是还有个问题无法解决，那就是 Buffer Pool 污染的问题</p>
<hr>
<h5 id="Buffer-Pool污染"><a href="#Buffer-Pool污染" class="headerlink" title="Buffer Pool污染"></a>Buffer Pool污染</h5><blockquote>
<p>什么是 Buffer Pool 污染？</p>
</blockquote>
<p>当某一个 SQL 语句<strong>扫描了大量的数据</strong>时，在 Buffer Pool 空间比较有限的情况下，可能会将 <strong>Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了</strong>，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 <strong>Buffer Pool 污染</strong>。</p>
<p>注意， Buffer Pool 污染并不只是查询语句查询出了大量的数据才出现的问题，即使查询出来的结果集很小，也可能会造成 Buffer Pool 污染（缓存失效导致全表扫描，从而将热点页淘汰，像前面这种全表扫描的查询，很多缓冲页其实只会被访问一次，但是它却只因为被访问了一次而进入到 young 区域，从而导致热点数据被替换了）</p>
<blockquote>
<p>怎么解决出现 Buffer Pool 污染而导致缓存命中率下降的问题？</p>
</blockquote>
<p>MySQL 是这样做的，进入到 young 区域条件增加了一个<strong>停留在 old 区域的时间判断</strong></p>
<p>具体是这样做的，在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：</p>
<ul>
<li>如果后续的访问时间与第一次访问的时间<strong>在某个时间间隔内</strong>，那么<strong>该缓存页就不会被从 old 区域移动到 young 区域的头部</strong>；</li>
<li>如果后续的访问时间与第一次访问的时间<strong>不在某个时间间隔内</strong>，那么<strong>该缓存页移动到 young 区域的头部</strong>；</li>
</ul>
<p>这个间隔时间是由 <code>innodb_old_blocks_time</code> 控制的，默认是 1000 ms。</p>
<p>也就说，<strong>只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部</strong>，这样就解决了 Buffer Pool 污染的问题 。</p>
<p>另外，MySQL 针对 young 区域其实做了一个优化，为了防止 young 区域节点频繁移动到头部，young 区域前面 1&#x2F;4 被访问不会移动到链表头部，只有后面的 3&#x2F;4被访问了才会</p>
<h4 id="4-脏页何时刷入磁盘"><a href="#4-脏页何时刷入磁盘" class="headerlink" title="4.脏页何时刷入磁盘"></a>4.脏页何时刷入磁盘</h4><p>如果在脏页还没有来得及刷入到磁盘时，MySQL 宕机了，不就丢失数据了吗？</p>
<p>这个不用担心，InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘，通过 redo log 日志让 MySQL 拥有了崩溃恢复能力。</p>
<p>下面几种情况会触发脏页的刷新：</p>
<ul>
<li>当 redo log 日志满了的情况下，会主动触发脏页刷新到磁盘；</li>
<li>Buffer Pool 空间不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；</li>
<li>MySQL 认为空闲时，后台线程会定期将适量的脏页刷入到磁盘；</li>
<li>MySQL 正常关闭之前，会把所有的脏页刷入到磁盘；</li>
</ul>
<h3 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h3><p>Innodb 存储引擎设计了一个<strong>缓冲池（Buffer Pool）</strong>，来提高数据库的读写性能。</p>
<p>Buffer Pool 以页为单位缓冲数据，可以通过 <code>innodb_buffer_pool_size</code> 参数调整缓冲池的大小，默认是 128 M。</p>
<p>Innodb 通过三种链表来管理缓页：</p>
<ul>
<li>Free List （空闲页链表），管理空闲页；</li>
<li>Flush List （脏页链表），管理脏页；</li>
<li>LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；</li>
</ul>
<p>InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 2 点优化：</p>
<ul>
<li>将 LRU 链表 分为<strong>young 和 old 两个区域</strong>，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决预读失效的问题。</li>
<li>当<strong>「页被访问」且「 old 区域停留时间超过 <code>innodb_old_blocks_time</code> 阈值（默认为1秒）」</strong>时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决批量数据访问，大量热数据淘汰的问题。</li>
</ul>
<p><strong>写操作是否有数据不一致性问题？</strong></p>
<p>有缓存时：</p>
<ul>
<li>读取数据，会命中缓冲池的页（已经被修改）。</li>
<li>缓冲池LRU数据淘汰，则会将【脏页】刷回磁盘。</li>
<li>数据库奔溃，redo log可以恢复数据</li>
</ul>
<p>无缓存时：走change buffer</p>
<ul>
<li>读取数据，会将Change Buffer中的数据合并到Buffer Pool中。</li>
<li>如果没有读取，Change也会被被定期刷盘到写缓冲系统表空间。</li>
<li>数据库奔溃，redo log可以恢复数据</li>
</ul>
<h2 id="7-3、Change-Buffer"><a href="#7-3、Change-Buffer" class="headerlink" title="7.3、Change Buffer"></a>7.3、Change Buffer</h2><blockquote>
<p>缓冲池技术主要对读操作进行了优化，在缓存存在时写操作也很高效，但缓存未命中时，<strong>至少产生一次磁盘IO</strong>，对于写多读少的业务场景可能会消耗大量资源，为了对写操作进行改进，InnoDB实现了写缓冲来提升数据库写性能</p>
</blockquote>
<p>写缓冲在MySQL5.5之前，叫插入缓冲(insert buffer)，只针对insert做了优化；现在对delete和update也有效，叫做写缓冲(change buffer)</p>
<p>它是一种应用在<strong>非唯一普通索引页</strong>(non-unique secondary index page)不在缓冲池中，对页进行了写操作，并不会立刻将磁盘页加载到缓冲池，而仅仅记录缓冲变更(buffer changes)，等未来数据被读取时，再将数据合并(merge)恢复到缓冲池中的技术。写缓冲的目的是降低写操作的磁盘IO，提升数据库性能</p>
<blockquote>
<p><strong>为什么写缓冲优化，仅适用于非唯一普通索引页？</strong></p>
</blockquote>
<p>如果索引设置了唯一(unique)属性，在进行修改操作时，InnoDB必须进行唯一性检查。也就是说，索引页即使不在缓冲池，磁盘上的页读取无法避免(否则怎么校验是否唯一？)，此时就应该直接把相应的页放入缓冲池再进行修改，而不应该再整写缓冲这个幺蛾子</p>
<blockquote>
<p><strong>哪些场景会触发刷写缓冲中的数据呢？</strong></p>
</blockquote>
<ol>
<li>数据页被访问</li>
<li>有一个后台线程，会认为数据库空闲时；</li>
<li>数据库缓冲池不够用时；</li>
<li>数据库正常关闭时；</li>
<li>redo log写满时；</li>
</ol>
<hr>
<p>Change Buffer被包含在了Buffer Pool中的，change buffer用的是buffer pool里的内存，由于Buffer Pool的内存大小是有限制的，所以change buffer大小也是有限制的，可通过参数innodb_change_buffer_max_size设置</p>
<img src="https://img-blog.csdnimg.cn/img_convert/8990f1a8e6fcedcca0b30c231d7a9e98.png" style="zoom:67%;" />

<h1 id="8、面经补充"><a href="#8、面经补充" class="headerlink" title="8、面经补充"></a>8、面经补充</h1><h2 id="1、分析一个update语句什么情况下会变得很慢"><a href="#1、分析一个update语句什么情况下会变得很慢" class="headerlink" title="1、分析一个update语句什么情况下会变得很慢"></a>1、分析一个update语句什么情况下会变得很慢</h2><blockquote>
<p>参考答案，不一定全对</p>
<ul>
<li>主键问题导致<strong>分页合并页</strong></li>
<li>update加载的段太大</li>
<li><strong>changbuffer</strong>中没有语句命中的行</li>
<li>有事务先对要更改的数据加锁导致阻塞</li>
<li>索引失效导致顺序查找</li>
</ul>
</blockquote>
<p>确实是不知道什么是分页合并页以及changebuffer，看面经真是越看越不会。。。 </p>
<h3 id="1、分页合并页"><a href="#1、分页合并页" class="headerlink" title="1、分页合并页"></a>1、分页合并页</h3><p>InooDB的文件格式，ibd利用主键索引到具体数据，数据都在叶节点上，frm就是一些数据库的元信息了。</p>
<p>重点看看ibd文件，这个文件由多个段组成，<strong>每个段和一个索引相关</strong>。</p>
<p>文件的结构是不会随着数据行的删除而变化的，但段则会跟着构成它的更小一级单位——区的变化而变化。页则是区的下一级构成单位，默认体积为16KB。</p>
<p>每个页（逻辑上讲即叶子节点）是包含了2-N行数据，根据主键排列。</p>
<p>每个页（逻辑上讲即<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9&spm=1001.2101.3001.7020">叶子节点</a>）是包含了2-N行数据，<strong>根据主键排列</strong>。</p>
<p>InnoDB不是按行的来操作的，它可操作的最小粒度是页，页加载进内存后才会通过扫描页来获取行&#x2F;记录</p>
<blockquote>
<p><strong>要注意的是在合并和分裂的过程中会加锁</strong></p>
</blockquote>
<h4 id="1-页合并"><a href="#1-页合并" class="headerlink" title="1.页合并"></a>1.页合并</h4><p>当你删了一行记录时，实际上记录<strong>并没有被物理删除</strong>，记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</p>
<p>当页中删除的记录达到<code>MERGE_THRESHOLD</code>（默认页体积的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p>
<p><strong>页合并发生在删除或更新操作中</strong>，关联到当前页的相邻页。如果页合并成功，在<code>INFOMATION_SCHEMA.INNODB_METRICS</code>中的<code>index_page_merge_successful</code>将会增加</p>
<h4 id="2-页分裂"><a href="#2-页分裂" class="headerlink" title="2.页分裂"></a>2.页分裂</h4><p>如果一个数据应该被插入第10页，但是10页满了，11页也满了，那怎么办？</p>
<p>直接把第10页分裂成两个，页分裂会发生在插入或更新，并且造成页的错位（dislocation，落入不同的区）</p>
<p>InnoDB用<code>INFORMATION_SCHEMA.INNODB_METRICS</code>表来跟踪页的分裂数。可以查看其中的<code>index_page_splits</code>和<code>index_page_reorg_attempts/successful</code>统计。</p>
<p>一旦创建分裂的页，唯一将原先顺序恢复的办法就是新分裂出来的页因为低于合并阈值（merge threshold）被删掉。这时候InnoDB用页合并将数据合并回来。</p>
<p>另一种方式就是用<code>OPTIMIZE</code>重新整理表。这可能是个很重量级和耗时的过程，但可能是唯一将大量分布在不同区的页理顺的方法</p>
<h1 id="附录补充"><a href="#附录补充" class="headerlink" title="附录补充"></a>附录补充</h1><h2 id="1、意向锁"><a href="#1、意向锁" class="headerlink" title="1、意向锁"></a>1、意向锁</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903666332368909">为什么要用意向锁</a></p>
<h2 id="2、不可重复读与幻读的区别"><a href="#2、不可重复读与幻读的区别" class="headerlink" title="2、不可重复读与幻读的区别"></a>2、不可重复读与幻读的区别</h2><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/392569386">不可重复读与幻读的区别</a></p>
<h2 id="3、行锁与表锁"><a href="#3、行锁与表锁" class="headerlink" title="3、行锁与表锁"></a>3、行锁与表锁</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/52678870">行锁与表锁</a></p>
<h2 id="4、时间类数据存储"><a href="#4、时间类数据存储" class="headerlink" title="4、时间类数据存储"></a>4、时间类数据存储</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/some-thoughts-on-database-storage-time.html#%E4%B8%8D%E8%A6%81%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%98%E5%82%A8%E6%97%A5%E6%9C%9F">Datatime和Timestamp</a></p>
<p><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/%E6%80%BB%E7%BB%93-%E5%B8%B8%E7%94%A8%E6%97%A5%E6%9C%9F%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F.jpg"></p>
<h2 id="5、MySQL中的隐式转换造成的索引失效"><a href="#5、MySQL中的隐式转换造成的索引失效" class="headerlink" title="5、MySQL中的隐式转换造成的索引失效"></a>5、MySQL中的隐式转换造成的索引失效</h2><p><a target="_blank" rel="noopener" href="https://javaguide.cn/database/mysql/index-invalidation-caused-by-implicit-conversion.html#%E5%89%8D%E8%A8%80">索引失效</a></p>
<p>MySQL 使用操作符的一些特性：</p>
<ol>
<li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li>
<li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li>
<li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li>
<li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果</li>
</ol>
<h2 id="6、MySQL死锁"><a href="#6、MySQL死锁" class="headerlink" title="6、MySQL死锁"></a>6、MySQL死锁</h2><p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/41285fabb8c4ca612d150b415">死锁</a></p>
<p>感觉讲的一般</p>
<h2 id="7、自旋锁与互斥锁"><a href="#7、自旋锁与互斥锁" class="headerlink" title="7、自旋锁与互斥锁"></a>7、自旋锁与互斥锁</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a7f349ddcf82">自旋锁</a></p>
<h2 id="8、MySQL优化"><a href="#8、MySQL优化" class="headerlink" title="8、MySQL优化"></a>8、MySQL优化</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_47162914/article/details/123793589">联合索引最左匹配原则优化</a></p>
<h2 id="9、RR隔离级别下幻读"><a href="#9、RR隔离级别下幻读" class="headerlink" title="9、RR隔离级别下幻读"></a>9、RR隔离级别下幻读</h2><p><a target="_blank" rel="noopener" href="https://www.xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97">RR级别下完全解决幻读了吗</a></p>
<h2 id="10、索引失效"><a href="#10、索引失效" class="headerlink" title="10、索引失效"></a>10、索引失效</h2><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w">https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://For-Melody.github.io">Melody</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://for-melody.github.io/2022/12/15/MySQL/">https://for-melody.github.io/2022/12/15/MySQL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://For-Melody.github.io" target="_blank">Melodyの博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://pictrue-bed.pages.dev/img/a78c8de3a671c5b31eff23ef4087b211.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/12/12/test/"><img class="prev-cover" src="https://pictrue-bed.pages.dev/img/a78c8de3a671c5b31eff23ef4087b211.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">测试</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="next-cover" src="https://pictrue-bed.pages.dev/img/a78c8de3a671c5b31eff23ef4087b211.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://pictrue-bed.pages.dev/img/102548934_p0_master1200.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Melody</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">3</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/For-Melody"><i></i><span>🛴前往小家...</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/For-Melody" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:185943464@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><b><font color="#a591e0">📬：这里是Melody的博客，记录很多有意思的东西和思考的内容</font></b></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E9%9D%A2%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">MySQL面试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">数据库基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A4%96%E7%A0%81%E9%94%AE%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">1、为什么不推荐使用外码键？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E8%8C%83%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">2、范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1NF-%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="toc-number">2.2.1.</span> <span class="toc-text">1NF(第一范式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2NF-%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="toc-number">2.2.2.</span> <span class="toc-text">2NF(第二范式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3NF-%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">3NF(第三范式)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81ACID"><span class="toc-number">2.3.</span> <span class="toc-text">3、ACID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.4.</span> <span class="toc-text">4、并发事务的问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL"><span class="toc-number">3.</span> <span class="toc-text">MySQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1%E3%80%81%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">4.</span> <span class="toc-text">1、基础架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MyISAM%E4%B8%8EInnoDB"><span class="toc-number">4.1.</span> <span class="toc-text">MyISAM与InnoDB</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2%E3%80%81MySQL%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">2、MySQL事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-ACID"><span class="toc-number">5.1.</span> <span class="toc-text">1.ACID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">2.并发事务的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">5.3.</span> <span class="toc-text">3.SQL事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.3.1.</span> <span class="toc-text">解决幻读的方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-MySQL-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97%EF%BC%9F"><span class="toc-number">5.4.</span> <span class="toc-text">4.MySQL 的隔离级别是基于锁实现的吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3%E3%80%81MySQL%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">3、MySQL锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A1%A8%E7%BA%A7%E9%94%81%E5%92%8C%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">6.1.</span> <span class="toc-text">1.表级锁和行级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A1%8C%E7%BA%A7%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E6%9C%89%E4%BB%80%E4%B9%88%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9F"><span class="toc-number">6.2.</span> <span class="toc-text">2.行级锁的使用有什么注意事项？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%85%B1%E4%BA%AB%E9%94%81%E5%92%8C%E6%8E%92%E4%BB%96%E9%94%81"><span class="toc-number">6.3.</span> <span class="toc-text">3.共享锁和排他锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">6.4.</span> <span class="toc-text">4.意向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-InnoDB-%E7%9A%84%E8%A1%8C%E9%94%81"><span class="toc-number">6.5.</span> <span class="toc-text">5.InnoDB 的行锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1%E3%80%81%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%88Record-Lock%EF%BC%89"><span class="toc-number">6.5.1.</span> <span class="toc-text">5.1、记录锁（Record Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2%E3%80%81%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88Gap-Lock%EF%BC%89"><span class="toc-number">6.5.2.</span> <span class="toc-text">5.2、间隙锁（Gap Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3%E3%80%81%E4%B8%B4%E7%95%8C%E9%94%81%EF%BC%88Next-Key-Lock%EF%BC%89"><span class="toc-number">6.5.3.</span> <span class="toc-text">5.3、临界锁（Next-Key Lock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4%E3%80%81%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81-Insert-Intention-lock"><span class="toc-number">6.5.4.</span> <span class="toc-text">5.4、插入意向锁( Insert Intention lock )</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB%E5%8C%BA%E5%88%AB"><span class="toc-number">6.6.</span> <span class="toc-text">6.当前读和快照读区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E3%80%81%E7%B4%A2%E5%BC%95"><span class="toc-number">7.</span> <span class="toc-text">4、索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">7.1.</span> <span class="toc-text">1、索引的底层数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Hash%E8%A1%A8"><span class="toc-number">7.1.1.</span> <span class="toc-text">1.Hash表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E4%BD%BF%E7%94%A8Hash%E8%A1%A8%E4%BD%9C%E4%B8%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">7.1.2.</span> <span class="toc-text">2.为什么不使用Hash表作为索引的数据结构？*</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-B-%E6%A0%91-amp-B-%E6%A0%91"><span class="toc-number">7.1.3.</span> <span class="toc-text">3.B 树&amp; B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MySQL%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B-%E6%A0%91"><span class="toc-number">7.1.4.</span> <span class="toc-text">4.MySQL为什么使用B+树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-InnoDB%E6%98%AF%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E7%9A%84"><span class="toc-number">7.1.5.</span> <span class="toc-text">5.InnoDB是如何存储数据的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#User-Records"><span class="toc-number">7.1.5.1.</span> <span class="toc-text">User Records</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-B-%E6%A0%91%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.1.6.</span> <span class="toc-text">6.B+树如何进行查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.2.</span> <span class="toc-text">2、索引类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95-Primary-Key"><span class="toc-number">7.2.1.</span> <span class="toc-text">1.主键索引(Primary Key)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.二级索引(辅助索引)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.3.</span> <span class="toc-text">3.聚集索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.4.</span> <span class="toc-text">4.非聚集索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.5.</span> <span class="toc-text">5.覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.6.</span> <span class="toc-text">6.自适应哈希索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">7.2.7.</span> <span class="toc-text">7.联合索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E8%8C%83%E5%9B%B4%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.2.7.1.</span> <span class="toc-text">联合索引范围查询</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">7.2.7.2.</span> <span class="toc-text">联合索引进行排序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">7.3.</span> <span class="toc-text">3、索引下推</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.</span> <span class="toc-text">4、索引优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.1.</span> <span class="toc-text">1.前缀索引优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">7.4.2.</span> <span class="toc-text">2.覆盖索引优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E6%9C%80%E5%A5%BD%E6%98%AF%E8%87%AA%E5%A2%9E%E7%9A%84"><span class="toc-number">7.4.3.</span> <span class="toc-text">3.主键索引最好是自增的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E6%9C%80%E5%A5%BD%E8%AE%BE%E7%BD%AE%E4%B8%BA-NOT-NULL"><span class="toc-number">7.4.4.</span> <span class="toc-text">4.索引最好设置为 NOT NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%98%B2%E6%AD%A2%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">7.4.5.</span> <span class="toc-text">5.防止索引失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">7.5.</span> <span class="toc-text">5、索引失效</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%B7%A6%E6%88%96%E8%80%85%E5%B7%A6%E5%8F%B3%E6%A8%A1%E7%B3%8A%E5%8C%B9%E9%85%8D"><span class="toc-number">7.5.1.</span> <span class="toc-text">1、对索引使用左或者左右模糊匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E5%AF%B9%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">7.5.2.</span> <span class="toc-text">2、对索引使用函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%AF%B9%E7%B4%A2%E5%BC%95%E8%BF%9B%E8%A1%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">7.5.3.</span> <span class="toc-text">3、对索引进行表达式计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E5%AF%B9%E7%B4%A2%E5%BC%95%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">7.5.4.</span> <span class="toc-text">4、对索引隐式类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E9%9D%9E%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D"><span class="toc-number">7.5.5.</span> <span class="toc-text">5、联合索引非最左匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6%E3%80%81WHERE-%E5%AD%90%E5%8F%A5%E4%B8%AD%E7%9A%84-OR"><span class="toc-number">7.5.6.</span> <span class="toc-text">6、WHERE 子句中的 OR</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5%E3%80%81%E6%97%A5%E5%BF%97%EF%BC%88binlog%EF%BC%8Credo-log%E5%92%8Cundo-log%EF%BC%89"><span class="toc-number">8.</span> <span class="toc-text">5、日志（binlog，redo log和undo log）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81redo-log%EF%BC%88%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-number">8.1.</span> <span class="toc-text">1、redo log（重做日志）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">8.1.1.</span> <span class="toc-text">刷盘时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-number">8.1.2.</span> <span class="toc-text">日志文件组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8redo-log"><span class="toc-number">8.1.3.</span> <span class="toc-text">为什么要用redo log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81binlog%EF%BC%88%E5%BD%92%E6%A1%A3%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-number">8.2.</span> <span class="toc-text">2、binlog（归档日志）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">8.2.1.</span> <span class="toc-text">记录格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">8.2.2.</span> <span class="toc-text">写入机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">8.3.</span> <span class="toc-text">3、两阶段提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81undo-log"><span class="toc-number">8.4.</span> <span class="toc-text">4、undo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">8.5.</span> <span class="toc-text">5、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6%E3%80%81MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">9.</span> <span class="toc-text">6、MVCC多版本并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E9%9D%9E%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-number">9.1.</span> <span class="toc-text">1、一致性非锁定读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-number">9.2.</span> <span class="toc-text">2、锁定读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81InnoDB%E5%AF%B9MVCC%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.3.</span> <span class="toc-text">3、InnoDB对MVCC的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">9.3.1.</span> <span class="toc-text">1.隐藏字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ReadView"><span class="toc-number">9.3.2.</span> <span class="toc-text">2.ReadView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-undo-log"><span class="toc-number">9.3.3.</span> <span class="toc-text">3.undo-log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%81%E6%80%A7%E7%AE%97%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">4、数据可见性算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81RC-%E5%92%8C-RR-%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B-MVCC-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">9.5.</span> <span class="toc-text">5、RC 和 RR 隔离级别下 MVCC 的差异</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81MVCC-%E8%A7%A3%E5%86%B3%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E9%97%AE%E9%A2%98"><span class="toc-number">9.6.</span> <span class="toc-text">6、MVCC 解决不可重复读问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81MVCC%E2%9E%95Next-key-Lock-%E9%98%B2%E6%AD%A2%E9%83%A8%E5%88%86%E5%B9%BB%E8%AF%BB"><span class="toc-number">9.7.</span> <span class="toc-text">7、MVCC➕Next-key-Lock 防止部分幻读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7%E3%80%81MySQL%E5%86%85%E5%AD%98"><span class="toc-number">10.</span> <span class="toc-text">7、MySQL内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1%E3%80%81MySQL%E4%B8%80%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%AD%98%E5%82%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">10.1.</span> <span class="toc-text">7.1、MySQL一行记录是怎么存储的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL%E6%95%B0%E6%8D%AE%E5%AD%98%E6%94%BE%E5%9C%A8%E4%BB%80%E4%B9%88%E6%96%87%E4%BB%B6%E4%B8%AD"><span class="toc-number">10.1.1.</span> <span class="toc-text">1.MySQL数据存放在什么文件中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">10.1.2.</span> <span class="toc-text">2.表空间文件的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E8%A1%8C%EF%BC%88row%EF%BC%89"><span class="toc-number">10.1.2.1.</span> <span class="toc-text">1、行（row）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E9%A1%B5%EF%BC%88page%EF%BC%89"><span class="toc-number">10.1.2.2.</span> <span class="toc-text">2、页（page）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%8C%BA%EF%BC%88extent%EF%BC%89"><span class="toc-number">10.1.2.3.</span> <span class="toc-text">3、区（extent）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E6%AE%B5%EF%BC%88segment%EF%BC%89"><span class="toc-number">10.1.2.4.</span> <span class="toc-text">4、段（segment）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-InnoDB-%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">10.1.3.</span> <span class="toc-text">3.InnoDB 行格式有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Compact%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">10.1.4.</span> <span class="toc-text">4.Compact行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF"><span class="toc-number">10.1.4.1.</span> <span class="toc-text">记录的额外信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8"><span class="toc-number">10.1.4.1.1.</span> <span class="toc-text">1. 变长字段长度列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-NULL-%E5%80%BC%E5%88%97%E8%A1%A8"><span class="toc-number">10.1.4.1.2.</span> <span class="toc-text">2. NULL 值列表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">10.1.4.1.3.</span> <span class="toc-text">3. 记录头信息</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE"><span class="toc-number">10.1.4.2.</span> <span class="toc-text">记录的真实数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-varchar-n-%E4%B8%AD-n-%E6%9C%80%E5%A4%A7%E5%8F%96%E5%80%BC%E4%B8%BA%E5%A4%9A%E5%B0%91%EF%BC%9F"><span class="toc-number">10.1.5.</span> <span class="toc-text">5.varchar(n) 中 n 最大取值为多少？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%A1%8C%E6%BA%A2%E5%87%BA%E5%90%8E%EF%BC%8CMySQL-%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86"><span class="toc-number">10.1.6.</span> <span class="toc-text">6.行溢出后，MySQL 怎么处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2%E3%80%81BufferPool"><span class="toc-number">10.2.</span> <span class="toc-text">7.2、BufferPool</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81Buffer-Pool%E7%BC%93%E5%AD%98"><span class="toc-number">10.2.1.</span> <span class="toc-text">1、Buffer Pool缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81Buffer-Pool%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">10.2.2.</span> <span class="toc-text">2、Buffer Pool的管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%A9%BA%E9%97%B2%E9%A1%B5%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">1.空闲页的管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%84%8F%E9%A1%B5%E7%9A%84%E7%AE%A1%E7%90%86"><span class="toc-number">10.2.2.2.</span> <span class="toc-text">2.脏页的管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E6%8F%90%E9%AB%98%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87"><span class="toc-number">10.2.2.3.</span> <span class="toc-text">3.如何提高缓存命中率</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E8%AF%BB%E5%A4%B1%E6%95%88"><span class="toc-number">10.2.2.3.1.</span> <span class="toc-text">预读失效</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Buffer-Pool%E6%B1%A1%E6%9F%93"><span class="toc-number">10.2.2.3.2.</span> <span class="toc-text">Buffer Pool污染</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%84%8F%E9%A1%B5%E4%BD%95%E6%97%B6%E5%88%B7%E5%85%A5%E7%A3%81%E7%9B%98"><span class="toc-number">10.2.2.4.</span> <span class="toc-text">4.脏页何时刷入磁盘</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">10.2.3.</span> <span class="toc-text">3、总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3%E3%80%81Change-Buffer"><span class="toc-number">10.3.</span> <span class="toc-text">7.3、Change Buffer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8%E3%80%81%E9%9D%A2%E7%BB%8F%E8%A1%A5%E5%85%85"><span class="toc-number">11.</span> <span class="toc-text">8、面经补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E5%88%86%E6%9E%90%E4%B8%80%E4%B8%AAupdate%E8%AF%AD%E5%8F%A5%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%98%E5%BE%97%E5%BE%88%E6%85%A2"><span class="toc-number">11.1.</span> <span class="toc-text">1、分析一个update语句什么情况下会变得很慢</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E5%88%86%E9%A1%B5%E5%90%88%E5%B9%B6%E9%A1%B5"><span class="toc-number">11.1.1.</span> <span class="toc-text">1、分页合并页</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A1%B5%E5%90%88%E5%B9%B6"><span class="toc-number">11.1.1.1.</span> <span class="toc-text">1.页合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A1%B5%E5%88%86%E8%A3%82"><span class="toc-number">11.1.1.2.</span> <span class="toc-text">2.页分裂</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95%E8%A1%A5%E5%85%85"><span class="toc-number">12.</span> <span class="toc-text">附录补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">12.1.</span> <span class="toc-text">1、意向锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E4%B8%8E%E5%B9%BB%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.2.</span> <span class="toc-text">2、不可重复读与幻读的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E8%A1%8C%E9%94%81%E4%B8%8E%E8%A1%A8%E9%94%81"><span class="toc-number">12.3.</span> <span class="toc-text">3、行锁与表锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E6%97%B6%E9%97%B4%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">12.4.</span> <span class="toc-text">4、时间类数据存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81MySQL%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%80%A0%E6%88%90%E7%9A%84%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">12.5.</span> <span class="toc-text">5、MySQL中的隐式转换造成的索引失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%81MySQL%E6%AD%BB%E9%94%81"><span class="toc-number">12.6.</span> <span class="toc-text">6、MySQL死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E3%80%81%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">12.7.</span> <span class="toc-text">7、自旋锁与互斥锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81MySQL%E4%BC%98%E5%8C%96"><span class="toc-number">12.8.</span> <span class="toc-text">8、MySQL优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81RR%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8B%E5%B9%BB%E8%AF%BB"><span class="toc-number">12.9.</span> <span class="toc-text">9、RR隔离级别下幻读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">12.10.</span> <span class="toc-text">10、索引失效</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://pictrue-bed.pages.dev/img/a78c8de3a671c5b31eff23ef4087b211.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2022 By Melody</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hibiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>